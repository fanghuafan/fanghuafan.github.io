<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Dubbo分布式调用链日志追踪]]></title>
    <url>%2Fposts%2F16401%2F</url>
    <content type="text"><![CDATA[为了在分布式系统快速定位问题及进行性能问题定位，我们需要知道引起性能问题的具体操作，然而在分布式系统中，一个请求往往会调用很多的服务（service），如何快速的定位，这个时候我们就需要分布式链路跟踪系统，如ZipKin，它会帮助我们快速定位问题根源。然而，本文不使用zipkin作为链路跟踪，通过自己实现，从Nginx—&gt;Tomcat—-&gt;Spring MVC Controller—&gt;Dubbo consumer—-&gt;Dubbo provider的链路跟踪，通过TraceId将一次请求的服务器所有执行日志串起来，可以帮助我们快速的定位问题根源，一、Nginx每个请求生成唯一的IDNginx生成唯一的$request_id作为日志追踪的trace_id，可以参考文章进行设置：点击查看 1proxy_set_header X-Request-Id $request_id; 二、Spring MVC Controller处理1、在Spring MVC Controller调用之前，可以通过设置一个拦截器，获取HTTP请求Header中的trace_id参数，通过MDC设置log4j日志对象中，再配置一下logback.xml就可以在controller执行的时打印出trace_id。2、同样的可以使用AOP在Controller调用之前将值设置到MDC中，实例如下：1234567891011@Component@Aspectpublic class LogAopAction &#123; @Pointcut(&quot;execution(* com.cdms.controller..*.*(..))&quot;) private void controllerAspect()&#123; HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); // 设置trace_id MDC.set(&quot;trace_id&quot;, request.getHeader(&quot;XXXX&quot;)); &#125;&#125; 三、Dubbo consumer filter配置重写Dubbo ConsumerContextFilter，在重写方法中的MDC设置trace_id，如下：1234567891011121314151617public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; //在当前的RpcContext中记录本地调用的一次状态信息 RpcContext.getContext() .setInvoker(invoker) .setInvocation(invocation) .setLocalAddress(NetUtils.getLocalHost(), 0) .setRemoteAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort()); if (invocation instanceof RpcInvocation) &#123; ((RpcInvocation)invocation).setInvoker(invoker); &#125; try &#123; return invoker.invoke(invocation); &#125; finally &#123; RpcContext.getContext().clearAttachments(); &#125; &#125; 四、Dubbo provider filter配置其实，provider的配置与consumer配置差不多一致，只需在每次provider调用前设置一个filter将trace_id提前设置到MDC中，在service执行过程中trace_id将会被打印出来。 重写ContextFilter，如下：12345678910111213141516171819202122232425262728public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; Map&lt;String, String&gt; attachments = invocation.getAttachments(); if (attachments != null) &#123; //隐式参数重剔除一些核心消息 attachments = new HashMap&lt;String, String&gt;(attachments); attachments.remove(Constants.PATH_KEY); attachments.remove(Constants.GROUP_KEY); attachments.remove(Constants.VERSION_KEY); attachments.remove(Constants.DUBBO_VERSION_KEY); attachments.remove(Constants.TOKEN_KEY); attachments.remove(Constants.TIMEOUT_KEY); &#125; //这里又重新将invocation和attachments信息设置到RpcContext，这里设置以后provider的代码就可以获取到consumer端传递的一些隐式参数了 RpcContext.getContext() .setInvoker(invoker) .setInvocation(invocation) .setAttachments(attachments) .setLocalAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort()); if (invocation instanceof RpcInvocation) &#123; ((RpcInvocation)invocation).setInvoker(invoker); &#125; try &#123; return invoker.invoke(invocation); &#125; finally &#123; RpcContext.removeContext(); &#125; &#125; （全文完）]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何正确的比较两个文件是否相同]]></title>
    <url>%2Fposts%2F18637%2F</url>
    <content type="text"><![CDATA[一、问题切入前段时间，有人问我：“如何判断两个文件是否相同？”，顿时让我想到了之前在技术博客上看到的文章，大部分都是说使用散列MD5的方法去判断，后来有个大神跟我说，他的结论：“两个相同的文件散列值一定相同，但是不同的文件有可能散列值相同”，为什么呢？ 二、问题求解首先回顾一下密码学中的散列函数 1、什么是散列算法呢？散列算法可以把【任意尺寸】的数据（原始数据）转变为一个【固定尺寸】的“小”数据（叫“散列值”或“摘要”）。 2、散列算法摘要长度对于某个具体的散列算法，得到的散列值长度总是固定的。散列值的长度又称“摘要长度”。以下是常见散列算法的摘要长度： CRC32 32比特（4字节） MD5 128比特（16字节） SHA1 160比特（20字节） 3、散列特点 不可逆性 从刚才的描述看，散列似乎有点像压缩。其实捏，散列算法跟压缩算法是完全不同滴。压缩算法是可逆的（可以把压缩后的数据再还原），而【散列算法是不可逆的】。 还有一些人把散列算法称为“加密算法”，这也是不对的。因为加密算法是可逆的（“加密”的逆操作就是“解密”），而散列算法是【不可逆】的。 确定性 通过某种散列算法，分别对两个原始数据计算散列值。如果算出来的散列值不同，那么可以 100% 肯定这两段数据是不同的——这就是“确定性”。 但反过来，如果这两段数据的散列值相同，则只能说，这两段数据【非常可能】相同。所谓的“非常可能”，就是说，还达不到百分百。具体原因，请看下一节“散列函数的可靠性”。 4、散列碰撞（1）、散列碰撞定义两段不同的原始数据，计算出相同的散列值。这种情况称之为“散列碰撞”或“散列冲突”。 （2）、碰撞类型 随机碰撞 随机碰撞就像买彩票中大奖，完全是出于小概率的偶然因素——你碰巧遇见两个不同的数据（文件），具有相同的散列值。 理论上讲，任何散列算法都存在随机碰撞的可能性，只是可能性有大有小。 人为碰撞 人为碰撞就是说，有人（通常是恶意的攻击者）故意制造散列碰撞，以此来骗过“基于散列值的完整性校验”。 三、问题结论由于散列算法存在碰撞，则我们使用散列MD5去判断两个文件是否相同是不科学的，正确的姿势应该是通过比较文件的内容去判断，如果是大文件，可以将文件切割成小片段进行比较。 下面是一段比较文件内容的shell脚本：1234567891011121314151617#!/bin/bashfile1=$1file2=$2if [ -f $file1 ] &amp;&amp; [ -f $file2 ]then diff $file1 $file2 &gt; /dev/null if [ $? != 0 ] then echo "Diff!" else echo "Same!" fielse echo "$file1 or $file2 does not exist, please check filename."fi]]></content>
      <categories>
        <category>散列算法</category>
      </categories>
      <tags>
        <tag>散列算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2Fposts%2F40991%2F</url>
    <content type="text"><![CDATA[一、Docker是什么？（1）、Docker概念Docker是以Docker容器为资源分离和调度的单位，封装整个软件运行的环境，为开发者和系统管理员设计的，用于构建、发布和运行分布式应用的平台，它是一个跨平台、可移植并且简单易用的容器解决方案。 （2）、Docker容器云容器云是以容器为资源分割和调度的基本单位，封装整个软件运行时环境，为开发者和系统管理员设计的，用于构建、发布和运行分布式应用的平台。当容器云专注于资源共享和隔离、容器编排和部署时，更接近于Iaas，当容器云渗透到应用支撑和运行环境时，它又接近于Pass. 二、Docker有何好处？ 持续部署和测试： 容器消除了线上线下环境的差异，保证了应用生命周期的环境一致性和标准化。 跨平台支持： Docker可以适配很多的云平台，如AWS/GCP/Azure等一系列云平台。 环境标准化和版本控制：基于容器提供的环境一致化和标准化，可以使用Git等工具进行环境管理， 高资源利用率和隔离： 容器没有管理系统的额外开销，与底层共享操作系统，性能优良，系统负载更低，在同等条件下可以运行更多的实例，可以充分利用系统的资源。 容器跨平台性和镜像： 容器在Linux基础上为容器设置一整套的标准化配置方案，将应用及其依赖运行环境打包成镜像，真正实现”构建一次，到处运行“的理念。 易于理解且易用： 一个开发可以在15分钟内理解Docker并且安装使用。 应用镜像仓库： Docker官方构建了一个类GitHub的仓库，所有人都可以下载微服务插件。 三、Docker的原理？Docker本质上是一个主机进程，通过namespace资源隔离，通过cgroups实现资源限制，通过写时复制机制（copy-on-write）实现高效的文件操作。 （1）、namespace资源隔离namespace 6项隔离 UTS： 主机名与域名 IPC: 信号量、消息队列和共享内存 PID: 进程编号 Network: 网络设备、网络线、端口等 Mount: 挂载点（文件系统） User： 用户和用户组 （2）、cgroups资源cgroups是Linux内核提供的一种机制，这种机制可以根据需求吧一系列系统任务及其子任务整合到按资源划分等级的不同组内，从而为系统提供统一的框架。它不仅可以限制被namespace隔离起来的资源，还可以为资源设置权重、计算使用量、操控任务的启停等。 四大功能： 资源限制：可以对任务使用的资源总额进行限制，超过则提示OOM; 优先级分配：通过分配CPU时间片数量和磁盘IO带宽大小，实际上就是控制了任务运行的优先级； 资源统计：统计系统资源的使用量； 任务控制：可以对任务实行挂起、恢复等操作。 组织结构和基本规则：传统的LInux是以init为根节点单根树形结构的任务模型，而docker则是多根树形结构的模型，不必受限于上一层级的任务，可以独自构成一个层级，易于管理。 规则： 同一个层级可以附加一个或者多个子系统； 一个子系统可以附加到多个子层级，当且仅当层级只有唯一一个子系统时； 系统每次新建一个层级时，该系统上的所有任务默认加入这个新建层级的初始化cgroups，这个cgroups也叫root cgroups; 任务在fork/clone自身时创建的子任务默认与原任务在同一个cgroups中，但是子任务允许被移动到不同的cgroups中。 （3）、Docker架构Docker使用了传统的cs架构模式（cilent-server），架构图如下图所示。用户通过Docker client与Docker daemon建立通信，并将请求发送给后者。而Docker的后端是松耦合结构，不同模块各司其职，有机组合，完成用户的请求。 Docker daemon Docker daemon是Docker最核心的后台进程，它负责响应来自Docker client的请求，然后将这些请求翻译成系统调用完成容器管理操作。该进程会在后台启动一个API Server，负责接收由Docker client发送的请求；接收到的请求将通过Docker daemon分发调度，再由具体的函数来执行请求。 Docker clientDocker client是一个泛称，用来向Docker daemon发起请求，执行相应的容器管理操作。它既可以是命令行工具docker，也可以是任何遵循了Docker API的客户端。目前，社区中维护着的Docker client种类非常丰富，涵盖了包括C#、 Java、Go、Ruby、JavaScript等常用语言，甚至还有使用Angular库编写的WebUI格式的客户端，足以满足大多数据用户的需求。 image managementDocker通过distribution、registry、layer、image、reference等模块实现了Docker镜像的管理，我们将这些模块统称为镜像管理（image management）。在Docker 1.10以前的版本中，这一功能通过graph组件来完成的。下面简单介绍一下： distribution负责与Docker registry交互，上传下载镜像以及存储v2 registry有关的元数据。registry模块负责与Docker registry有关的身份验证、镜像查找、镜像验证以及管理registry mirror等交互操作。image模块负责与镜像元数据有关的存储、查找，镜像层的索引、查找以及镜像tar包有关的导入、导出等操作。reference负责存储本地所有镜像的repository和tag名，并维护与镜像ID之间的映射关系。layer模块负责与镜像层和容器层元数据有关的增删查改，并负责将镜像层的增删查改操作映射到实际存储镜像层文件系统的graphdriver模块。 execdriver、volumedriver、graphdriver前面提到，Docker daemon负责将用户请求转译成系统调用，进而创建和管理容器。而在具体实现过程中，为了将这些系统调用抽象成为统一的操作接口方便调用者使用，Docker把这些操作分成了容器执行驱动、volume存储驱动、镜像存储驱动这3种，分别对应execdriver、volumedriver、graphdriver： execdriver是对Linux系统的namespaces、cgroups、apparmor、SELinux等容器运行所需的系统操作进行的一层二次封装，其本质作用类似于LXC，但是功能要更全面。这也就是为什么LXC会作为execdriver的一种实现而存在。当然，execdriver最主要的实现，也是现在的默认实现，是Docker官方编写的libcontainer库。 volumedriver是volume数据卷存储操作的最终执行者，负责volume的增删改查，屏蔽不同驱动实现的区别，为上层调用者提供一个统一的接口。Docker中作为默认实现的volumedriver是local，默认将文件存储于Docker根目录下的volume文件夹里。其他的volumedriver均是通过外部插件实现的。graphdriver是所有与容器镜像相关操作的最终执行者。graphdriver会在Docker工作目录下维护一组与镜像层对应的目录，并记下镜像层之间的关系以及与具体的graphdriver实现相关的元数据。这样，用户对镜像的操作最终会被映射成对应这些目录文件以及元数据的增删改查，从而屏蔽掉不同文件存储实现对于上层调用者的影响。在Linux环境下，目前Docker已经支持graphdriver包括aufs、btrfs、zfs、overlay和vfs。 network在Docker 1.9版本以前，网络是通过networkdriver模块以及libcontainer库完成的，现在这部分功能已经分离成一个libnetwork库独立维护了，可参考 https://github.com/docker/libnetwork 。libnetwork抽象出了一个容器网络模型（Container Network Model，CNM），并给调用者提供了一个抽象接口，其目标不权限于Docker容器。CNM模型对真实的容器网络抽象出了沙盒（sandbox）、端点（endpoint）、网络（network）这3种对象，由具体网络驱动（包括内置的Bridge、Host、None和overlay驱动以及通过插件配置的外部驱动）操作对象，并通过网络控制器提供一个统一接口供调用者管理网络。网络驱动负责实现具体的操作，包括创建容器通信所需的网络，容器的network namespace，这个网络所需的虚拟网卡，分配通信所需的IP，服务访问的端口和容器与宿主机之间的端口映射，设置hosts、resolv.conf、iptables等。 （4）、Docker基本命令 容器生命周期管理 — docker [run|start|stop|restart|kill|rm|pause|unpause] 容器操作运维 — docker [ps|inspect|top|attach|events|logs|wait|export|port] 容器rootfs命令 — docker [commit|cp|diff] 镜像仓库 — docker [login|pull|push|search] 本地镜像管理 — docker [images|rmi|tag|build|history|save|import] 其他命令 — docker [info|version] http://blog.51cto.com/ganbing/2073184《Docker容器与容器云》]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-no11（DP）]]></title>
    <url>%2Fposts%2F52530%2F</url>
    <content type="text"><![CDATA[problem： Regular Expression MatchingGiven an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’. ‘.’ Matches any single character.‘*’ Matches zero or more of the preceding element.The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z.p could be empty and contains only lowercase letters a-z, and characters like . or *. code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/*函数声明 */ bool isMatch(char* s, char* p);int main(int argc, char* argv[]) &#123; printf("\n---------------通配符匹配算法---------------\n"); printf("请输入待匹配串：\n"); char *s; scanf("%s",&amp;s); printf("请输入匹配串：\n"); char *p; scanf("%s",&amp;p); bool isMatchRes = isMatch(s, p); printf("算法匹配结果：%d\n", isMatchRes); // test_1(); printf("\n---------------通配符匹配算法---------------\n"); system("pause"); return 0; &#125; //////////////////////////////////// 通配符算法一 ////////////////////////////////bool helper(char* s, char* p, int i, int j, int sl, int pl, bool** mark) &#123; if(i == sl &amp;&amp; j == pl) return true; // Exhaust both at the same time if(i &gt; sl || j &gt;= pl) return false; // return false if i and j reach corresponding lengths // except when i == sl and j &lt; pl if(mark[i][j]) return false; // Do not want to do repeating job mark[i][j] = true; if(j &lt; pl - 1 &amp;&amp; p[j + 1] == '*') &#123; if(s[i] == p[j] || p[j] == '.') &#123; // If p[j] works for s[i] return helper(s, p, i, j + 2, sl, pl, mark) // Ignore the star || helper(s, p, i + 1, j, sl, pl, mark) // Continue hanging out with the star || helper(s, p, i + 1, j + 2, sl, pl, mark); // p[j] and p[j+1] works like a '.' &#125; return helper(s, p, i, j + 2, sl, pl, mark); // If p[j] does not work, ignore the star &#125; if(s[i] == p[j] || p[j] == '.') return helper(s, p, i + 1, j + 1, sl, pl, mark); // If p[j] works, proceed return false;&#125;bool isMatch_1(char* s, char* p) &#123; int sl = strlen(s); int pl = strlen(p); // 2D list to keep track of the pairs of indices that have been visited bool** mark = (bool**) calloc(sl + 1, sizeof(bool*)); for(int i = 0; i &lt; sl + 1; i++) &#123; mark[i] = (bool*) calloc(pl + 1, sizeof(bool)); for(int j = 0; j &lt; pl + 1; j++) &#123; mark[i][j] = false; &#125; &#125; bool res = helper(s, p, 0, 0, sl, pl, mark); // Free stuff for(int i = 0; i &lt; sl + 1; i++) &#123; free(mark[i]); &#125; free(mark); return res;&#125;//////////////////////////////////// 通配符算法二 ////////////////////////////////bool isMatch(char *s, char *p)&#123; int s_len = 0, p_len = 0; while(s[s_len] != 0) s_len++; while(p[p_len] != 0) p_len++; s_len++;p_len++; bool m[p_len][s_len]; memset(m, 0, p_len*s_len); m[0][0] = true; for (int i = 1 ; i &lt; p_len ; i++) m[i][0] = i &gt; 1 &amp;&amp; p[i-1] == '*' &amp;&amp; m[i-2][0] ? true : false; for (int i = 1 ; i &lt; p_len ; i++) &#123; for (int j = 1 ; j &lt; s_len ; j++) &#123; if (p[i-1] != '*') m[i][j] = m[i-1][j-1] &amp;&amp; (p[i-1] == '.' || p[i-1] == s[j-1]); else m[i][j] = m[i-2][j] || ((m[i-2][j-1] || m[i][j-1]) &amp;&amp; (p[i-2] == '.' || p[i-2] == s[j-1])); &#125; &#125; return m[p_len-1][s_len-1];&#125; the end]]></content>
      <categories>
        <category>Algorithm</category>
        <category>leetcode</category>
        <category>动态规划算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>leetcode</tag>
        <tag>动态规划算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DevOps学习]]></title>
    <url>%2Fposts%2F25442%2F</url>
    <content type="text"><![CDATA[前面在Jenkins学习的文章文章中已经简要介绍了DevOps相关概念。 DevOps理论：DevOps基于精益、约束理论、丰田生产系统、柔性工程、学习型组织、安全文化、人员优化等知识体系，并参考了高信任度文化、服务型领导、组织变化管理等方法论，把所有这些最可信的原则综合地运用于IT系统价值流中，就可以产生出这样的成果。 精益二原则： 1、坚持前置时间是提升质量、客户满意度和员工幸福感的最佳度量指标之一； 2、小批量任务交付是缩短前置时间的一个关键因素。 敏捷原则：频繁交付可工作的软件，推荐尽可能缩短交付周期，强调使用小批量任务进行增量发布，建立自组织的小团队，让成员在高度信任的环境中愉悦的工作。 持续交付持续交付基于持续构建、测试和集成的开发原则，部署流水线确保代码和基础设置都是可部署状态，所提交到主干的代码都是可以安全的部署到生产环境的。 DevOps的基础原则DevOps的基础原则是三步工作法： 1、流动原则（从左到右的工作流） 2、反馈原则（从右到左的快速、持续的反馈） 3、持续学习与实验原则（建立持续学习与实验的文化） 第一工作法，从开发到IT运维再到客户的整个自左向右的工作流。通过建立完整的持续构建、集成以及部署和严控半成品，帮助我们形成一条迅速、可预测、持续不断的计划内工作流、从而向业务部门交付工作价值，同时尽可能降低计划外工作的影响和破坏，逐步提供稳定的、可预期的、安全的IT服务。 第二工作法，价值流各阶段自右向左的快速持续反馈流，放大其效益以防止问题再次发生，或者更快地发现和修复问题。加速问题的反馈，可以缩短及放大反馈环路，在源头上解决问题，避免问题逐步放大。一旦问题反馈不及时，后续基于此产品的工作，只会让错误成倍的放大。此外，合理的反馈流可以减少意外工作的干扰。 第三工作法，关于创造公司文化，该文化可带动两种风气的形成。当成功的构建了第一和第二工作法，下来就是需要增强产品信心，营造一种勇于创新、冒险的环境，高信任度的文化。这就要不断给系统施加压力，不断强化学习并加以改进，比如反复的故障演练、反复的安装部署等。 草考文献：《DevOps实践指南》《DevOps软件架构师行动指南》]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一段导出gitlab工程的python脚本]]></title>
    <url>%2Fposts%2F2883%2F</url>
    <content type="text"><![CDATA[安装python-gitlab1pip install python-gitlab 1234567891011121314151617181920212223242526272829303132#!/usr/bin/python# -*- coding: UTF-8 -*-import gitlabdef auth(): gl = gitlab.Gitlab('http://192.168.1.105', private_token='dfshgjkdfgcxvhjkdshfa') gl.auth() return gldef project_list(): gl = auth() projects = gl.projects.list(all=True) if(projects != None): for project in projects: download_project(gl, project)def download_project(gl, p): export = p.exports.create(&#123;&#125;) # Wait for the 'finished' status export.refresh() while export.export_status != 'finished': time.sleep(1) export.refresh() # Download the result with open('C://', 'wb') as f: export.download(streamed=True, action=f.write)project_list() 注意：GitLab版本至少10.6]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 去除不扫描]]></title>
    <url>%2Fposts%2F37767%2F</url>
    <content type="text"><![CDATA[Spring MVC中去除不需扫描的类： 1234&lt;context:component-scan base-package="com.foo" use-default-filters="false"&gt; &lt;context:include-filter type="regex" expression="com.foo.bar.*Config"/&gt; &lt;context:include-filter type="regex" expression="com.foo.config.*"/&gt;&lt;/context:component-scan&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitLab Architecture（架构）]]></title>
    <url>%2Fposts%2F63291%2F</url>
    <content type="text"><![CDATA[一、GitLab是什么？GitLab是由GitLab Inc.开发，使用MIT许可证的基于网络的Git仓库管理工具，且具有wiki和issue跟踪功能。 GitLab 是一个用于仓库管理系统的开源项目。 使用Git作为代码管理工具，并在此基础上搭建起来的web服务。Github是公共的git仓库，而Gitlab适合于搭建企业内部私有git仓库。 二、GitLiab架构如何？ 官网上将组件架构类比成一个物理的办公室，下面是一些组件的描述： repository：这个仓库用户操作处理一些货物，它们都可以存在在这些仓库中，这个仓库是硬盘或者一些复杂的东西，例如NFS文件系统； Nginx：Nginx扮演一个前台的工作，用户首先来到前台并请求办公室员工做一些事情，实际上就是一个GitLab Web的代理工具； Database： Database就是办公室的一个文件储物柜； 可以存储仓库中货物的一些操作处理（如：元数据，issue，合并请求 merge request 等） 可以存储用户校验、权限记录 Redis：Redis是一个包含办公室员工的交流板，作缓存，分发任务用； Sidekiq：Sidekiq是一个主要负责发送邮件的办公室员工，他的任务都是来自于Redis交流板中； Unicorn：Unicorn是一个主要负责处理快速/普通任务的办公室员工，他与Redis交流板协同处理任务，他的一些具体任务描述； 从Redis储物柜中拿出用户的session检查用户的权限; 给Sidekiq创建任务； 从仓库中取货物或者移动仓库中的货物； GitLab-shell：GitLab-shell是第三种办公室员工，他使用一部传真机（SSH）代替前台（HTTP）传递命令，他通过Redis和Sidekiq进行通信，并直接或通过 TCP 间接访问 Unicorn； Gitaly：后台服务，专门负责访问磁盘以高效处理 git 操作，并缓存耗时操作。所有的 git 操作都通过 Gitaly 处理； GitLab-workhorse：反向代理服务器，可以处理与 Rails 无关的请求（磁盘上的 CSS、JS 文件等），处理 Git Push/Pull 请求，处理到 Rails 的连接（修改由 Rails 发送的响应或发送给 Rails 的请求，管理 Rails 的长期 WebSocket 连接等） GitLab持续集成组件 GitLab-CI：GitLab-CI就是一套配合GitLab使用的持续集成系统（当然，还有其它的持续集成系统，同样可以配合GitLab使用，比如Jenkins）。而且GitLab8.0以后的版本是默认集成了GitLab-CI并且默认启用的。 GitLab-Runner：GitLab-Runner是配合GitLab-CI进行使用的。一般地，GitLab里面的每一个工程都会定义一个属于这个工程的软件集成脚本，用来自动化地完成一些软件集成工作。当这个工程的仓库代码发生变动时，比如有人push了代码，GitLab就会将这个变动通知GitLab-CI。这时GitLab-CI会找出与这个工程相关联的Runner，并通知这些Runner把代码更新到本地并执行预定义好的执行脚本。 GitLab-Runner可以分类两种类型：Shared Runner（共享型）和Specific Runner（指定型）： Shared Runner：这种Runner（工人）是所有工程都能够用的。只有系统管理员能够创建Shared Runner。 Specific Runner：这种Runner（工人）只能为指定的工程服务。拥有该工程访问权限的人都能够为该工程创建Shared Runner。 参考文献：https://docs.gitlab.com/ce/development/architecture.htmlhttps://blog.csdn.net/kikajack/article/details/80354774https://www.tuicool.com/articles/bYbi2mJhttps://docs.gitlab.com/ee/ci/README.html#doc-navhttps://www.cnblogs.com/cnundefined/p/7095368.htmlhttps://docs.gitlab.com/runner/]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins学习]]></title>
    <url>%2Fposts%2F32639%2F</url>
    <content type="text"><![CDATA[一、Jenkins是什么？学习jenkins之前我们先来学习几个相关概念。 1、了解DevOps首先了解DevOps，WIKI上是这样描述DevOps，DevOps（Development和Operations的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。DevOps的终极目标是打破信息的孤岛，让开发与运维之间更好的协作。协作目的是确保应用能快速地由开发流转到测试，再到运维。当运维遇到问题的时候，能建制一个完整的闭环回到开发环节。 2、持续集成（Continuous integration，简称CI）持续集成即频繁地（一天多次）将代码集成到主干。 它的好处主要有两个： （1）快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。 （2）防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。Martin Fowler说过，”持续集成并不能消除Bug，而是让它们非常容易发现和改正。” 与持续集成相关的，还有两个概念，分别是持续交付和持续部署。 3、持续交付（Continuous delivery，简称CD）持续交付即频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。 4、持续部署（continuous deployment，简称CD）持续部署即持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。持续部署的前提是能自动化完成测试、构建、部署等步骤。 5、下面看几张DevOps系统架构图 第一张是阿里云的DevOps，第二张是腾讯云的DevOps，这两张图都充分体现出开发、运维、测试、产品/运营人员之间的闭环协作关系，同时更能体现了持续集成、交付、部署的工作流程。 二、Jenkins有何用？为了更好地说明Jenkins的功能和作用，上一节中我们引入了devOps和持续集成等概念，而Jenkins跟这几个概念又有什么联系呢？接下来我们看看jenkins到底有什么大作用。 1、中间协调器上图很深刻的反应Jenkins的中间协调器功能，Jenkins通过集成各个对应软件的插件，使得原本不相关软件可以协同工作，从而实现了开发、运维、测试、产品/运营一条龙运作，提高工作效率的同时保证工作质量。 2、持续、自动构建、测试软件项目我所认为的关于持续、自动构建、测试软件项目的流程应类似于以上的流程图。 3、监控定时任务Jenkins提供了一些场景的定时任务，比如构建的定时任务，有点儿类似于Quartz定时任务的实现。 三、Jenkins原理是什么？其实，上面已经把Jenkins的主要功能列举出来，Jenkins主要是集成插件以实现项目持续集成、交付、部署的一系列功能，下面街介绍下三种持续集成方案： 1、CI/CD原理CI(Continuous Integration)持续集成，CD(Continuous Delivery) 持续交付，通常会采用一些软件如Jenkins、Drone、Travis、Gocd等来辅助项目流程。CI/CD能够与Git SVN等代码管理仓库集成，帮助使用者实现自动化任务。 2、Jenkins原理①定时拉取代码并编译或者自定义触发器hock拉取代码②打包发布版本③分析打包编译后的结果④完成编译后的自定义操作 3、Jenkins+Docker原理①从代码仓库拉取最新的代码。②Jenkins主机打包编译代码。③Jenkins主机使用Dockerfile生成最新的镜像，并push到仓库。④Docker主机pull最新的镜像，删除旧的容器，并生成最新的容器，完成部署上线。 四、Jenkins如何实现？源码地址：https://github.com/jenkinsci/jenkins（待续……） 五、Jenkins如何应用？关于Jenkins的应用，在网上找到一篇写的很好的文章：Jenkins应用 参考文献与书籍http://www.360doc.com/content/16/0301/07/412471_538441377.shtmlhttp://www.ruanyifeng.com/blog/2015/09/continuous-integration.htmlhttps://develop.aliyun.com/devops?spm=5176.128995.655207.1.23336464LHwsbihttps://cloud.tencent.com/solution/devopshttps://zh.wikipedia.org/wiki/DevOpshttps://www.cnblogs.com/liyuanhong/p/6548925.htmlhttps://juejin.im/entry/5a97b0def265da23a334a25d《Jenkins权威指南》]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven学习]]></title>
    <url>%2Fposts%2F8081%2F</url>
    <content type="text"><![CDATA[一、maven是什么？ Apache Maven，是一个软件（特别是Java软件）项目管理及自动构建工具，由Apache软件基金会所提供。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。 Maven也可被用于构建和管理各种项目，例如C#，Ruby，Scala和其他语言编写的项目。Maven曾是Jakarta项目的子项目，现为由Apache软件基金会主持的独立Apache项目。 二、maven有何用？日常工作中maven使用最多的就是Java工程师使用maven进行工程项目的依赖管理，其实maven主要作用就两个： 统一开发规范与工具 统一管理jar包 三、maven原理是什么？1、两个基本概念（1）、POMPOM的全称是Project Object Model，用通俗点的话说就是对要构建的项目进行建模，将要构建的项目看成是一个对象（Object）。在maven中一个项目都是用一个唯一的坐标（coordinate）来表示，坐标由groupId, artifactId, version, classifier, type这五部分组成。这样来说PO应该也要具备坐标属性。另外，一个项目会依赖另一个项目，所以PO应该具备dependencies属性，同样的，PO对象也有其父对象，用parent属性来表示，并且PO对象会继承其父对象的所有属性。另外一方面，一个项目可能根据不同职责分为多个模块（module），所有模块其实也就是一个单独的项目，只不过这些项目会使用其父对象的一些属性来进行构建。综上，这个用Java描述的的PO对象为： 12345678910class PO&#123; private String groupId; private String artifactId; private String version; private String classifier; private String type; private Set&lt;PO&gt; dependencies; private PO parent; private Set&lt;PO&gt; modules;&#125; 其PO对象所在pom.xml中对应的是标签中的内容。 （2）、LifeCycleLifecycle顾名思义就是生命周期的意思，一个LifeCycle包括多个phase，正常一个标准的LifeCycle以下的phase: 12345678910111213141516171819202122validate： 用于验证项目的有效性和其项目所需要的内容是否具备initialize：初始化操作，比如创建一些构建所需要的目录等。generate-sources：用于生成一些源代码，这些源代码在compile phase中需要使用到process-sources：对源代码进行一些操作，例如过滤一些源代码generate-resources：生成资源文件（这些文件将被包含在最后的输入文件中）process-resources：对资源文件进行处理compile：对源代码进行编译process-classes：对编译生成的文件进行处理generate-test-sources：生成测试用的源代码process-test-sources：对生成的测试源代码进行处理generate-test-resources：生成测试用的资源文件process-test-resources：对测试用的资源文件进行处理test-compile：对测试用的源代码进行编译process-test-classes：对测试源代码编译后的文件进行处理test：进行单元测试prepare-package：打包前置操作package：打包pre-integration-test：集成测试前置操作 integration-test：集成测试post-integration-test：集成测试后置操作install：将打包产物安装到本地maven仓库deploy：将打包产物安装到远程仓库 而phase就相当于对应java的一个接口定义，而此时引入另一个概念—goal，goal就是一个phase的具体实现，一个goal在maven中就是一个Mojo（Maven old java object）。Mojo抽象类中定义了一个execute()方法，一个goal的具体动作就是在execute()方法中实现。而goal对应的就是maven pom.xml中的。 综上，总结以上几个概念： POM(Project Object Model)：工程对象模型，对应pom.xml中的。 LifeCycle:maven的的生命周期对应多个phase，phase有对应一个具体的动作实现goal，吗，每个phase都会对应一个具体的goal，goal对应pom.xml中的。 四、maven什么实现？maven是使用Java实现，Githu上的地址：https://github.com/apache/maven。（待续） 五、maven什么应用？maven主要用于管理工程依赖与编译工程，可以作为持续集成工具的一部分，下面主要介绍一些常用命令： 1、mvn常用参数mvn -e 显示详细错误 mvn -U 强制更新snapshot类型的插件或依赖库（否则maven一天只会更新一次snapshot依赖） mvn -o 运行offline模式，不联网更新依赖 mvn -N 仅在当前项目模块执行命令，关闭reactor mvn -pl module_name在指定模块上执行命令 mvn -ff 在递归执行命令过程中，一旦发生错误就直接退出 mvn -Dxxx=yyy 指定java全局属性 mvn -Pxxx 引用profile xxx 2、Build Lifecycle中介绍的命令mvn test-compile 编译测试代码 mvn test 运行程序中的单元测试 mvn compile 编译项目 mvn package 打包，此时target目录下会出现maven-quickstart-1.0-SNAPSHOT.jar文件，即为打包后文件 mvn install 打包并安装到本地仓库，此时本机仓库会新增maven-quickstart-1.0-SNAPSHOT.jar文件。 3、maven日用三板斧mvn archetype:generate 创建maven项目 mvn package 打包，上面已经介绍过了 mvn package -Prelease打包，并生成部署用的包，比如deploy/*.tgz mvn install 打包并安装到本地库 mvn eclipse:eclipse 生成eclipse项目文件 mvn eclipse:clean 清除eclipse项目文件 mvn site 生成项目相关信息的网站 mvn archetype:generate 创建maven项目 mvn validate 验证项目是否正确 mvn jar:jar 只打jar包 mvn source:jar 生成源码jar包 mvn generate-sources 产生应用需要的任何额外的源代码 mvn compile 编译源代码 mvn verify 运行检查 mvn idea:idea 生成idea项目 mvn:deploy 发布项目到远程仓库 mvn integration-test 在集成测试可以运行的环境中处理和发布包 mvn dependency:tree 显示maven依赖树 mvn dependency:list 显示maven依赖列表 mvn dependency:sources 下载依赖包的源码 mvn install:install-file -DgroupId=packageName -DartifactId=projectName -Dversion=version -Dpackaging=jar -Dfile=path 安装本地jar到本地仓库 4、web项目相关命令mvn tomcat:run 启动tomcat mvn jetty:run 启动jetty mvn tomcat:deploy 运行打包部署 mvn tomcat:undeploy 撤销部署 mvn tomcat:start 启动web应用 mvn tomcat:stop 停止web应用 mvn tomcat:redeploy 重新部署 mvn war:exploded tomcat:exploded 部署展开的war文件 参考文献与书籍https://zh.wikipedia.org/wiki/Apache_Mavenhttps://www.jianshu.com/p/0fb5e3fb704dhttps://zhuanlan.zhihu.com/p/29208926]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习]]></title>
    <url>%2Fposts%2F1%2F</url>
    <content type="text"><![CDATA[一、git是什么？ git是一个分布式版本控制软件，最初由林纳斯·托瓦兹（Linus Torvalds）创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。应注意的是，这与GNU Interactive Tools[6]有所不同。 二、git有何用？git的相关介绍 git是用于Linux内核开发的版本控制工具。与CVS、Subversion一类的集中式版本控制工具不同，它采用了分布式版本库的作法，不需要服务器端软件，就可以运作版本控制，使得源代码的发布和交流极其方便。git的速度很快，这对于诸如Linux内核这样的大项目来说自然很重要。git最为出色的是它的合并追踪（merge tracing）能力。 git的主要功能： 更具体的git可以概括为以下几点功能用处： 代码托管：现在比较比较流行的代码托管平台有GitHub、Gitee(码云)以及一些可以自己搭建的git代码托管平台，如Ruby实现的gitlab、golang实现的gogs等一些开源平台； 团队协作：与SVN集中式版本管理系统不同，Git客户端并非仅仅检出文件的最新快照，而是对代码仓库进行完整的镜像，如此，不管哪一个服务器出现故障，任何一个客户端都可以使用自己本地的代码仓库镜像恢复服务器，这是代码完整性的保证性；其次，团队可以根据自身需求选择git的分布式工作流进行工程项目管理，通过pull/push/merge等操作进行仓库版本管理，使得团队协作更加便捷高效。 三、git原理是什么？git的两张原理架构图 git库目录 hooks：存储钩子的文件夹 logs：存储日志的文件夹 refs：存储指向各个分支的指针（SHA-1标识）文件 objects：存放git对象 config：存放各种设置文档 HEAD：指向当前所在分支的指针文件路径，一般指向refs下的某文件 git几个重要名词 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 git分布式工作流集中式工作流集中式工作流是针对与代码仓库来说的，所有开发人员使用同一个代码仓库进行协同工作，所有工作的内容提交到一个Trunk或者Master的分支上。 集成管理者工作流Git中可以创建多个仓库，集成管理者工作流的核心就是项目的主仓库由“集成者”负责，其它开发人员拥有自己的仓库，开发者把完成的工作提交到自己的公开库中，然后“集成者”从这些公开库中拉取代码，最终合并到主仓库中. 司令官与副官工作流司令官与副官工作流是集成管理者工作流的拓展，引入了多级“集成者”来完成多级的代码合并操作，该模式适用于复杂的多级管理的项目开发. Git钩子（Git Hooks） Git和其它版本控制系统一样，能在特定的重要动作发生时触发自定义脚本。 客户端钩子：由诸如提交和合并这样的操作所调用； 服务器端钩子：作用于诸如接收被推送的提交这样的联网操作。 四、git什么实现？Git是Linus Torvalds用C语言实现的，GitHub仓库地址：https://github.com/git/git。（待续） 五、git如何应用？1、新建代码库# 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 2、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot; 3、增加/删除文件# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 4、代码提交# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 5、分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 6、标签# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 7、查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 8、远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 9、撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 10、其他# 生成一个可供发布的压缩包 $ git archive # 查找任何提交树或工作目录中的字符串和正则表达式 ￥ git grep 参考文献与书籍https://www.cnblogs.com/selimsong/p/9059964.htmlhttps://zh.wikipedia.org/wiki/Githttp://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.htmlhttps://www.jianshu.com/p/527e34f53b51?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation《精通Git (第二版)》]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java(String)的replaceFirst、replaceAll、replace区别]]></title>
    <url>%2Fposts%2F14145%2F</url>
    <content type="text"><![CDATA[replace和replaceAll是JAVA中常用的替换字符的方法,它们的区别是: 1) replace的参数是char和CharSequence,即可以支持字符的替换,也支持字符串的替换(CharSequence即字符串序列的意思,说白了也就是字符串); 2) replaceAll的参数是regex,即基于规则表达式的替换,比如,可以通过replaceAll(“\d”, “*”)把一个字符串所有的数字字符都换成星号; 相同点是都是全部替换,即把源字符串中的某一字符或字符串全部换成指定的字符或字符串,如果只想替换第一次出现的,可以使用 replaceFirst(),这个方法也是基于规则表达式的替换,但与replaceAll()不同的是,只替换第一次出现的字符串; 另外,如果replaceAll()和replaceFirst()所用的参数据不是基于规则表达式的,则与replace()替换字符串的效果是一样的,即这两者也支持字符串的操作; 引用文章https://blog.csdn.net/cynhafa/article/details/8190489]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery操作table的一些实现]]></title>
    <url>%2Fposts%2F21846%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;moban&lt;/title&gt; &lt;script src="http://www.w3school.com.cn/jquery/jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function showzhi(obj)&#123; // 获取table tr的td列表 var x = $(obj).parent().parent().find("td"); // 获取td中select的默认选中值 var y = x.eq(2).find("select").val(); // 清空td中select的下拉框值 x.eq(2).find("select").empty(); // 添加td中select下拉框的值 x.eq(2).find("select").append("&lt;option value='223'&gt;Text-1&lt;/option&gt;"); x.eq(2).find("select").append("&lt;option value='23213'&gt;Text-2&lt;/option&gt;"); x.eq(2).find("select").append("&lt;option value='12323'&gt;Text-3&lt;/option&gt;"); x.eq(2).find("select").append("&lt;option value='232323'&gt;Text-4&lt;/option&gt;"); // 设置td中select下拉框的默认选中值 x.eq(2).find("select").val('12323'); alert(y); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table width="80%" border="1"&gt; &lt;tr&gt; &lt;td&gt;111&lt;/td&gt; &lt;td&gt;aaa&lt;/td&gt; &lt;td&gt; &lt;select&gt; &lt;option value="1"&gt;测试仪&lt;/option&gt; &lt;option value="11"&gt;测试仪1&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt;&lt;a onclick="showzhi(this)"&gt;保存&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;222&lt;/td&gt; &lt;td&gt;bbb&lt;/td&gt; &lt;td&gt; &lt;select&gt; &lt;option value="1"&gt;测试仪&lt;/option&gt; &lt;option value="12" selected&gt;测试仪2&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt;&lt;a onclick="showzhi(this)"&gt;保存&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;333&lt;/td&gt; &lt;td&gt;ccc&lt;/td&gt; &lt;td&gt; &lt;select&gt; &lt;option value="1"&gt;测试仪&lt;/option&gt; &lt;option value="13" selected&gt;测试仪3&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt;&lt;a onclick="showzhi(this)"&gt;保存&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git暂存stash命令]]></title>
    <url>%2Fposts%2F60448%2F</url>
    <content type="text"><![CDATA[当git fetch发现远程分支已经修改，存在merge合并冲突，可以试着先使用git stash命令将当前的工作区保存起来，等待pull(fetch/merge之后再还原)。1、git stash // 暂存修改到工作区 2、git pull // 拉取远程分支【最好使用git fetch/git merge代替】 3、git stash pop stash@{0} // 将工作区还原 4、git status // 发现修改文件还是呈现红色 5、git add . // 添加文件跟踪 6、git commit -m &apos;注释&apos; // 提交到本地分支 7、git push origin &lt;远程分支名称&gt; // 提交到远程分支 注：如果还原工作区与pull(fetch/merge)发生冲突，需要手动解决冲突]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM+SPICE安装配置文档]]></title>
    <url>%2Fposts%2F43868%2F</url>
    <content type="text"><![CDATA[CentOS7.2部署KVM虚拟机一、安装KVM#####1. 验证CPU是否支持KVM；如果结果中有vmx（Intel）或svm(AMD)字样，就说明CPU的支持的1egrep &apos;(vmx|svm)&apos; /proc/cpuinfo #####2. 关闭SELinux，将 /etc/sysconfig/selinux 中的 SELinux=enforcing 修改为 SELinux=disabled【非必须】12vim /etc/sysconfig/selinux然后修改SELinux=enforcing 修改为 SELinux=disabled，重启后生效，不重启不影响后续安装配置 #####3. 最小安装的CentOS安装一些最基本的包（可选项，因为我是刚安装好的CentOS，所以为了下面方便点，先把一些必要的工具安装下） yum install epel-release net-tools vim unzip zip wget ftp -y #####4. 安装KVM及其依赖项 yum install qemu-kvm libvirt virt-install bridge-utils -y #####5. 验证安装结果，下图说明已经成功安装了 lsmod | grep kvm #####6. 开启kvm服务，并且设置其开机自动启动 systemctl start libvirtd systemctl enable libvirtd #####7. 查看状态操作结果,如下图所示，说明运行情况良好 systemctl status libvirtd systemctl is-enabled libvirtd #####8. 配置网桥模式，先将 /etc/sysconfig/network-scripts/ 目录下的网卡配置文件备份一份(不要备在当前目录以及子目录下，其他目录随意) a. 创建 ifcfg-br0 文件，内容如下： BOOTPROTO=static DEVICE=br0 TYPE=Bridge NM_CONTROLLED=no IPADDR=192.168.1.95 NETMASK=255.255.255.0 GATEWAY=192.168.1.1 DNS1=61.177.7.1 DNS2=8.8.8.8 b. 移除掉原来的 ifcfg-enp0s25 ,重新创建该文件，内容如下： BOOTPROTO=none DEVICE=enp0s25 NM_CONTROLLED=no ONBOOT=yes BRIDGE=br0 c. 重启网络服务 systemctl restart network 使用 ifconfig 验证操作结果,多了一块网卡br0，现在访问 think8848-srv02 使用 192.168.1.95 就可以了。 二、KVM安装虚拟机安装前提创建目录 mkdir -p /home/iso 下载服务器镜像文件到虚拟主机上 cd /homg/iso wget http://192.168.6.101/static/system/cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso wget http://192.168.6.101/static/system/cn_windows_10_enterprise_2016_ltsb_x64_dvd_9060409.iso 创建虚拟机文件存放的目录 mkdir -p /home/kvm-bak 本地【自己】电脑上安装virt-viewer(自行网上下载)[]([下载](https://releases.pagure.org/virt-viewer/virt-viewer-x64-1.0.msi &quot;Download&quot;)) win10安装qemu-img create -f raw /home/iso/kvm-0.raw 100G qemu-img info /home/iso/kvm-0.raw virt-install --virt-type kvm --name win10-10 --ram 4096 --cdrom=/home/iso/cn_windows_10_enterprise_2016_ltsb_x64_dvd_9060409.iso --boot cdrom --cpu core2duo --network bridge=br0,model=&apos;e1000&apos; --graphics vnc,listen=0.0.0.0 --disk path=/home/iso/kvm-0.raw,bus=&apos;ide&apos; --noautoconsole --os-type=windows --force --autostart win7安装qemu-img create -f raw /home/iso/kvm-1.raw 100G qemu-img info /home/iso/kvm-1.raw virt-install --virt-type kvm --name win7-0 --ram 4096 --cdrom=/home/iso/cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso --boot cdrom --cpu core2duo --network bridge=br0,model=&apos;e1000&apos; --graphics vnc,listen=0.0.0.0 --disk path=/home/iso/kvm-1.raw,bus=&apos;ide&apos; --noautoconsole --os-type=windows --force --autostart 可以参考下一下几篇文章https://www.cnblogs.com/yang-ning/p/7111649.html?utm_source=debugrun&amp;utm_medium=referralhttps://www.linuxidc.com/Linux/2017-01/140007.htm KVM中系统配置SPICE协议使用命令关闭虚拟机virsh shutdown win7-0 virsh shutdown win10-10 注：这个过程要等一会儿 配置spice远程连接修改虚拟机的配置文件 win7-0 cd /etc/libvirt/qemu/ vim win7-0.xml virsh edit win7-0[这个命令比较坑爹，用上面命令替代] &lt;!-- 首先virsh命令关闭虚拟机,使用`virsh edit domain`编辑 --&gt; &lt;!-- 添加 --&gt; &lt;channel type=&apos;spicevmc&apos;&gt; &lt;target type=&apos;virtio&apos; name=&apos;com.redhat.spice.0&apos;/&gt; &lt;/channel&gt; &lt;!-- 修改 --&gt; &lt;graphics type=&apos;spice&apos; port=&apos;-1&apos; autoport=&apos;yes&apos; listen=&apos;0.0.0.0&apos;&gt; &lt;listen type=&apos;address&apos; address=&apos;0.0.0.0&apos;/&gt; &lt;/graphics&gt; &lt;video&gt; &lt;model type=&apos;qxl&apos; heads=&apos;1&apos;/&gt; &lt;alias name=&apos;video0&apos;/&gt; &lt;/video&gt; 保存重启 virsh start win7-0 使用virt-viewer连接【spice://192.168.6.100:5900】 参考文献https://opengers.github.io/virtualization/spice-kvm-usbredir-qxl-1/ 实例地址：spice://192.168.6.100:5900spice://192.168.6.100:5901]]></content>
      <categories>
        <category>server</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>JKVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA反射中，Class.forName和classloader的区别]]></title>
    <url>%2Fposts%2F34422%2F</url>
    <content type="text"><![CDATA[JAVA中class.forName()和classLoader都可用来对类进行加载： class.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。 Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象]]></content>
      <categories>
        <category>JAVA</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DELL R730xd服务器风扇问题解决]]></title>
    <url>%2Fposts%2F53555%2F</url>
    <content type="text"><![CDATA[DELL R730xd 加装PCIE显卡风扇问题 国外网站看到一个IMPI的解决方法，禁用对第三方PCI卡的风扇响应 1. Install IPMI tools:yum install OpenIPMI OpenIPMI-tools chkconfig ipmi on # &lt;&lt; optional for the task service ipmi start # &lt;&lt; optional for the task 2. Query Dell’s Third-Party PCIe card based default system fan response:ipmitool raw 0x30 0xce 0x01 0x16 0x05 0x00 0x00 0x00 # response like below means Disabled 16 05 00 00 00 05 00 01 00 00 # response like below means Enabled 16 05 00 00 00 05 00 00 00 00 3. Jets off or Set Third-Party PCIe Card Default Cooling Response Logic To Disabled:ipmitool raw 0x30 0xce 0x00 0x16 0x05 0x00 0x00 0x00 0x05 0x00 0x01 0x00 0x00 4. Jets on or Set Third-Party PCIe Card Default Cooling Response Logic To Enabled:ipmitool raw 0x30 0xce 0x00 0x16 0x05 0x00 0x00 0x00 0x05 0x00 0x00 0x00 0x00 serverfault.com/.../how-do-i-stop-dell-r730xd-fans-from-going-full-speed-when-broadcom-qlogic-netxtr 参考文献https://serverfault.com/questions/715387/how-do-i-stop-dell-r730xd-fans-from-going-full-speed-when-broadcom-qlogic-netxtr]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular中请求Spring Boot接口缺少X-Application-Context报错]]></title>
    <url>%2Fposts%2F23032%2F</url>
    <content type="text"><![CDATA[Angular中请求Spring Boot接口缺少X-Application-Context报错可以再Spring Boot的配置文件Application.yml中增加：12management: add-application-context-header: false 同时处理跨域的问题：123456789101112131415@Configurationpublic class CORSConfiguration &#123; @Bean public WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping("/**") .allowedHeaders("*") .allowedMethods("*") .allowedOrigins("*"); &#125; &#125;; &#125;&#125; 引用：https://stackoverflow.com/questions/40379550/what-is-x-application-context-header]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[httpclient SSL请求异常处理]]></title>
    <url>%2Fposts%2F6932%2F</url>
    <content type="text"><![CDATA[今天突然发现请求微信小程序获取OpenID的接口报错，看了一下日志，找了好久发现是SSl版本的原因，之前没有问题，今天重启了一次就出现这个问题。 javax.net.ssl.SSLHandshakeException: Remote host closed connection during handshake at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:992) at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1375) at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1403) at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1387) at org.apache.http.conn.ssl.SSLConnectionSocketFactory.createLayeredSocket(SSLConnectionSocketFactory.java:394) at org.apache.http.conn.ssl.SSLConnectionSocketFactory.connectSocket(SSLConnectionSocketFactory.java:353) at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:141) at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:353) at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:380) at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236) at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:184) at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:88) at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110) at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:184) at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82) at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:107) at com.kupa.common.util.HttpsUtils.post(HttpsUtils.java:163) at com.kupa.controller.api.wx.account.AccountController.checkLogin(AccountController.java:245) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:220) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:116) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:963) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:897) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) at javax.servlet.http.HttpServlet.service(HttpServlet.java:635) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.kupa.filter.CORSFilter.doFilter(CORSFilter.java:42) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449) at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365) at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90) at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83) at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:383) at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:80) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:624) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:799) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:861) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1455) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748) Caused by: java.io.EOFException: SSL peer shut down incorrectly at sun.security.ssl.InputRecord.read(InputRecord.java:505) at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:973) ... 69 common frames omitted 解决方法： 在stackoverflow上找到答案： https://stackoverflow.com/questions/21245796/javax-net-ssl-sslhandshakeexception-remote-host-closed-connection-during-handsh主要是因为SSL版本的问题。 // 原来代码 // sslsf = new SSLConnectionSocketFactory(builder.build(), new String[] { "SSLv2Hello", "SSLv3", "TLSv1.1", "TLSv1.2" }, // null, NoopHostnameVerifier.INSTANCE); // 修改后 sslsf = new SSLConnectionSocketFactory(builder.build(), new String[] { "TLSv1.1", "TLSv1.2" }, null, NoopHostnameVerifier.INSTANCE);]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2Fposts%2F39554%2F</url>
    <content type="text"><![CDATA[适配器模式（Adapter Pattern）是一种结构模式，主要是实现类、对象、接口的兼容性， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/* * Copyright,ShanNong Inc,2018 and onwards * * Author:fanghua fan */package com.fanghua.designpattrn.adapter;/** * 适配器模式 */public class ClassAdapterPattern &#123; public static void main(String[] args) &#123; System.out.println("客户开始挑选电器……"); OperatorElectricalEquipment om11 = new OperatorElectricalEquipment(); om11.buy(Country.AMERICA); om11.testRunning(); System.out.println(); OperatorElectricalEquipment om22 = new OperatorElectricalEquipment(); om22.buy(Country.GERMANY); om22.testRunning(); System.out.println(); OperatorElectricalEquipment om33 = new OperatorElectricalEquipment(); om33.buy(Country.JAPAN); om33.testRunning(); System.out.println(); System.out.println("客户成功挑选电器……"); &#125;&#125;class OperatorElectricalEquipment &#123; private Country name; /** * 用户买电器 * * @param name * @return */ public int buy(Country name) &#123; this.name = name; System.out.println("用户成功买到：" + name.getName() + "电器"); return 200; &#125; /** * 启动电器 * * @return */ public int testRunning() &#123; System.out.println("电压正在开始适配……"); // 创建适配器 VoltageAdapter adpter = new VoltageAdapter(); adpter.outputVoltage(name); System.out.println("适配" + name.getName() + "标准电压成功！"); System.out.println("正在启动电器……"); System.out.println("启动电器成功！"); return 200; &#125;&#125;/** * 中国正常电压220V */class ChinaVoltage220 &#123; /** * 输出中国电压标准 * * @return */ public int output220V() &#123; int srcVoltage = 220; System.out.println("中国正常家用电压" + srcVoltage + "V"); return srcVoltage; &#125;&#125;/** * 国家标准电压接口 */interface CountryStandardVoltage &#123; int outputVoltage(Country name);&#125;/** * 正常电压适配器 */class VoltageAdapter extends ChinaVoltage220 implements CountryStandardVoltage &#123; int src = output220V(); /** * 电压适配器 * * @param name * @return */ public int outputVoltage(Country name) &#123; int dst = 0; switch (name) &#123; case AMERICA: dst = (int)(src / ((double)src / 110)); break; case JAPAN: dst = (int)(src / ((double)src / 120)); break; case GERMANY: dst = (int)(src / ((double)src / 230)); break; default: dst = src; &#125; System.out.println(name.getName() + "适配电压成功，当前电压：" + dst + 'V'); return dst; &#125;&#125;/** * 国家枚举 */enum Country &#123; AMERICA("美国"), JAPAN("日本"), GERMANY("德国"); private String name; Country(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; return "Country&#123;" + "name='" + name + '\'' + '&#125;'; &#125;&#125; 输出结果：1234567891011121314151617181920212223242526客户开始挑选电器……用户成功买到：美国电器电压正在开始适配……中国正常家用电压220V美国适配电压成功，当前电压：110V适配美国标准电压成功！正在启动电器……启动电器成功！用户成功买到：德国电器电压正在开始适配……中国正常家用电压220V德国适配电压成功，当前电压：230V适配德国标准电压成功！正在启动电器……启动电器成功！用户成功买到：日本电器电压正在开始适配……中国正常家用电压220V日本适配电压成功，当前电压：120V适配日本标准电压成功！正在启动电器……启动电器成功！客户成功挑选电器……]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2Fposts%2F22548%2F</url>
    <content type="text"><![CDATA[原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 所谓原型模式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。 在原型模式中，所发动创建的对象通过请求原型对象来拷贝原型对象自己来实现创建过程，当然所发动创建的对象需要知道原型对象的类型。这里也就是说所发动创建的对象只需要知道原型对象的类型就可以获得更多的原型实例对象，至于这些原型对象时如何创建的根本不需要关心。 讲到原型模式了，我们就不得不区分两个概念：深拷贝、浅拷贝。 浅拷贝：使用一个已知实例对新创建实例的成员变量逐个赋值，这个方式被称为浅拷贝。 深拷贝：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创建新的实例，并且初始化为形式参数实例值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/* * Copyright,ShanNong Inc,2018 and onwards * * Author:fanghua fan */package com.fanghua.designpattrn.prototype;import java.util.Hashtable;/** * 原型模式 */public class PrototypePattern &#123; public static void main(String[] args) &#123; MathCache.loadCache(); Math clonedShape = (Math) MathCache.getMath(1); System.out.println("Math : " + clonedShape.study()); Math clonedShape2 = (Math) MathCache.getMath(2); System.out.println("Math : " + clonedShape2.study()); &#125;&#125;/** * 数学抽象接口 */abstract class Math implements Cloneable &#123; private Integer id; private String name; public abstract String study(); public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Object clone() &#123; Object clone = null; try &#123; clone = super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125;&#125;/** * 数学分析学习 */class AnalysicsMath extends Math &#123; public String study() &#123; System.out.println("Analysics study!"); return "ok"; &#125;&#125;/** * 数论学习 */class NumberTheoryMath extends Math &#123; public String study() &#123; System.out.println("NumberYheoryMath study!"); return "ok"; &#125;&#125;/** * 对象缓存 */class MathCache &#123; private static Hashtable&lt;Integer, Math&gt; shapeMap = new Hashtable&lt;Integer, Math&gt;(); public static Math getMath(Integer shapeId) &#123; Math cachedShape = shapeMap.get(shapeId); return (Math) cachedShape.clone(); &#125; public static void loadCache() &#123; AnalysicsMath a = new AnalysicsMath(); a.setId(1); shapeMap.put(a.getId(), a); NumberTheoryMath n = new NumberTheoryMath(); n.setId(2); shapeMap.put(n.getId(), n); &#125;&#125; 参考文献：https://www.cnblogs.com/chenssy/p/3313339.htmlhttp://www.runoob.com/design-pattern/prototype-pattern.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-no5]]></title>
    <url>%2Fposts%2F45091%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/* * Copyright,ShanNong Inc,2018 and onwards * * Author:fanghua fan */package com.fanghua.algorithm.divideandconquer;/** * Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. * &lt;p&gt; * Example: * Input: "babad" * Output: "bab" * &lt;p&gt; * Note: "aba" is also a valid answer. * &lt;p&gt; * Example: * Input: "cbbd" * Output: "bb" */public class SolutionNum5 &#123; /** * 第一式：动态规划解法 * 两层深度遍历，左右两边同时遍历， * 使用二维数组存储各个回文串开始和结束位置， * 找到左右两边字母相同且以及子串回文， * 时间复杂度是O(n^2) * * @param s * @return */ public String longestPalindromeDynamic(String s) &#123; int n = s.length(); String res = null; boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i; j &lt; n; j++) &#123; dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; 3 || dp[i + 1][j - 1]); if (dp[i][j] &amp;&amp; (res == null || j - i + 1 &gt; res.length())) &#123; res = s.substring(i, j + 1); &#125; &#125; &#125; return res; &#125; /** * 第二式：中心开花式 * 全遍历一次字符串，以每个字符为中心进行回文判断，直到回文结束为止 * * @param s * @return */ public String longestPalindrome(String s) &#123; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1); &#125; private int expandAroundCenter(String s, int left, int right) &#123; int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123; L--; R++; &#125; return R - L - 1; &#125; /** * 第三式：Manacher算法 * Manacher法只能解决例如aba这样长度为奇数的回文串， * 对于abba这样的不能解决，于是就在里面添加特殊字符。 * 我是添加了“#”，使abba变为a#b#b#a。 * 这个算法就是利用已有回文串的对称性来计算的，具体算法复杂度为O(N) * @param s * @return */ public String longestPalindromeWithManacher(String s) &#123; char[] chArray = s.toCharArray(); int len = chArray.length * 2 + 3; char[] nch = new char[len]; nch[0] = '@'; // 3. 添加特殊字符，防止访问越界 nch[len-1] = '$'; for (int i=1; i&lt;len-1; i++) &#123; if ((i &amp; 1) != 0) &#123; nch[i] = '#'; // 1. 在字符串中添加特殊字符，将两种情况统一解决 &#125; else &#123; nch[i] = chArray[(i&gt;&gt;1) - 1]; &#125; &#125; int[] p = new int[len]; int maxid = 0, center = 0, longest = 1, longestCenter = 0; for (int i=1; i&lt;len-1; i++) &#123; // 2. 算法的精华 if (maxid &gt; i) &#123; p[i] = Math.min(p[2*center-i], maxid-i); &#125; else &#123; p[i] = 1; &#125; while (nch[i-p[i]]==nch[i+p[i]]) &#123; p[i]++; &#125; if (p[i]+i &gt; maxid) &#123; maxid = p[i]+i; center = i; &#125; if (longest &lt; p[i]) &#123; longest = p[i]; longestCenter = center; &#125; &#125; StringBuilder sb = new StringBuilder(); for (int i=longestCenter+1-longest; i&lt;longestCenter+longest; i++) &#123; if (nch[i] != '#') sb.append(nch[i]); &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>leetcode</category>
        <category>动态规划算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>leetcode</tag>
        <tag>动态规划算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xenserver删除VM存储无法释放]]></title>
    <url>%2Fposts%2F16051%2F</url>
    <content type="text"><![CDATA[（1）执行命令：1xe vdi-list， 如果记得之前分配给VM磁盘的name-lable，可以通过name-lable查找，如果不记得了，找到与你之前分配给VM的存储大小接近的磁盘，如下： （2）找到以后输入命令1lvremove /dev/VG_XenStorage-&lt;sr-uuid&gt;/VHD-&lt;vdi-uuid&gt; 有可能会提示： lvremove /dev/VG_XenStorage-6f5e0962-afcd-8222-18fe-eb02292d327b/VHD-bd9c17f5-4571-4f4a-92de-ce64049f0c1a: Command not permitted while global/metadata_read_only is set. 解决办法： [root@xen dev]# lvremove /dev/VG_XenStorage-6f5e0962-afcd-8222-18fe-eb02292d327b/VHD-bd9c17f5-4571-4f4a-92de-ce64049f0c1a --config global{metadata_read_only=0} 结果： Logical volume &quot;VHD-bd9c17f5-4571-4f4a-92de-ce64049f0c1a&quot; successfully removed （3）重启xenserver:1reboot]]></content>
      <categories>
        <category>xenserver</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2Fposts%2F29711%2F</url>
    <content type="text"><![CDATA[建造者模式（Builder Pattern）属于创建型模式，它使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* * Copyright,ShanNong Inc,2018 and onwards * * Author:fanghua fan */package com.fanghua.designpattrn.build;import java.util.ArrayList;import java.util.List;public class BuliderPattern &#123; public static void main(String[] args) &#123; //找到该店的老板和装机人员 Boss boss = new Boss(); Builder builder = new WorkerBuilder(); //沟通需求后，老板叫装机人员去装电脑 boss.command(builder); //装完后，组装人员搬来组装好的电脑 Computer computer = builder.GetComputer(); //组装人员展示电脑给小成看 computer.Show(); &#125;&#125;/** * 组装电脑操作 */abstract class Builder &#123; //声明为抽象方法，安装CPU public abstract void BuildCPU(); //声明为抽象方法，安装主板 public abstract void BuildMainboard(); //声明为抽象方法，安装显卡 public abstract void BuildHD(); //返回产品的方法：获得组装好的电脑 public abstract Computer GetComputer();&#125;/** * 老板发布组装电脑任务 */class Boss &#123; // 指挥装机人员组装电脑 public void command(Builder builder) &#123; builder.BuildCPU(); builder.BuildMainboard(); builder.BuildHD(); &#125;&#125;class WorkerBuilder extends Builder &#123; //创建产品实例 Computer computer = new Computer(); //组装产品 @Override public void BuildCPU() &#123; computer.Add("组装CPU"); &#125; @Override public void BuildMainboard() &#123; computer.Add("组装主板"); &#125; @Override public void BuildHD() &#123; computer.Add("组装显卡"); &#125; //返回组装成功的电脑 @Override public Computer GetComputer() &#123; return computer; &#125;&#125;/** * 电脑概述 */class Computer &#123; //电脑组件的集合 private List&lt;String&gt; parts = new ArrayList&lt;String&gt;(); //用于将组件组装到电脑里 public void Add(String part) &#123; parts.add(part); &#125; public void Show() &#123; for (int i = 0; i &lt; parts.size(); i++) &#123; System.out.println("部件" + parts.get(i) + "组装完成"); &#125; System.out.println("电脑组装完成，启动看看"); &#125;&#125; https://blog.csdn.net/carson_ho/article/details/54910597 （全文完）4/2/2018 11:07:24 PM]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2Fposts%2F56455%2F</url>
    <content type="text"><![CDATA[抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/* * Copyright,ShanNong Inc,2018 and onwards * * Author:fanghua fan */package com.fanghua.designpattrn.abstractfactory;public class AbstractFactoryPattern &#123; public static void main(String[] args) &#123; AbstractFactory sf = FactoryProducer.getFactory(FactoryType.ARTS_FACTORY); LiberalArts asf = sf.getArts(LiberalArtsType.HISTORY); asf.artsContent(); &#125;&#125;/** * 理科 */interface Science &#123; void scienceContent();&#125;/** * 文科 */interface LiberalArts &#123; void artsContent();&#125;/** * 数学分析 */class AnalysicsMath implements Science &#123; public void scienceContent() &#123; System.out.println("greate math!"); &#125;&#125;/** * 理论物理学 */class TheoreticalPhysics implements Science &#123; public void scienceContent() &#123; System.out.println("greate physics!"); &#125;&#125;/** * 历史学 */class History implements LiberalArts &#123; public void artsContent() &#123; System.out.println("beautiful history!"); &#125;&#125;/** * 政治学 */class Politics implements LiberalArts &#123; public void artsContent() &#123; System.out.println("beautiful politics!"); &#125;&#125;/** * 抽象工厂 */abstract class AbstractFactory &#123; abstract Science getScience(ScienceType name); abstract LiberalArts getArts(LiberalArtsType name);&#125;/** * 理科工厂 */class ScienceFactory extends AbstractFactory &#123; Science getScience(ScienceType name) &#123; switch (name) &#123; case MATH: return new AnalysicsMath(); case PHYSICS: return new TheoreticalPhysics(); &#125; return null; &#125; LiberalArts getArts(LiberalArtsType name) &#123; return null; &#125;&#125;/** * 文科工厂 */class LiberalArtsFactory extends AbstractFactory &#123; Science getScience(ScienceType name) &#123; return null; &#125; LiberalArts getArts(LiberalArtsType name) &#123; switch (name) &#123; case HISTORY: return new History(); case POLITICS: return new Politics(); &#125; return null; &#125;&#125;/** * 理科对象类型枚举 */enum ScienceType &#123; MATH, PHYSICS&#125;/** * 文科对象类型枚举 */enum LiberalArtsType &#123; HISTORY, POLITICS&#125;/** * 工厂类型 */enum FactoryType &#123; SCIENCE_FACTORY, ARTS_FACTORY&#125;/** * 工厂对象提供者 */class FactoryProducer &#123; public static AbstractFactory getFactory(FactoryType choice) &#123; switch (choice) &#123; case SCIENCE_FACTORY: return new ScienceFactory(); case ARTS_FACTORY: return new LiberalArtsFactory(); &#125; return null; &#125;&#125; （全文完）4/2/2018 9:09:08 PM]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2Fposts%2F6013%2F</url>
    <content type="text"><![CDATA[工厂模式（Factory Pattern）是创建型模式的一种，在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* * Copyright,ShanNong Inc,2018 and onwards * * Author:fanghua fan */package com.fanghua.designpattrn.factory;/** * 工厂模式 */public class Factory &#123; /** * 工厂中获取指定对象 * * @param name * @return */ public static Math getInstance(Instance name) &#123; Math object; switch (name) &#123; case ANALYSIS: object = new Analysis(); break; case CALCULUE: object = new Calculue(); break; default: object = null; &#125; return object; &#125; public static void main(String[] args) &#123; // 数学分析 Factory.getInstance(Instance.ANALYSIS).study(); // 微积分 Factory.getInstance(Instance.CALCULUE).study(); &#125;&#125;/** * 数学类 */interface Math &#123; void study(); String getName();&#125;/** * 微积分 */class Calculue implements Math &#123; public void study() &#123; System.out.println("print out calculue!"); &#125; public String getName() &#123; return "calculue"; &#125;&#125;/** * 数学分析 */class Analysis implements Math &#123; public void study() &#123; System.out.println("print out analysis!"); &#125; public String getName() &#123; return "analysis"; &#125;&#125;/** * 实例枚举 */enum Instance &#123; CALCULUE,// 微积分 ANALYSIS // 数学分析&#125; （全文完）4/1/2018 9:55:45 PM]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2Fposts%2F60114%2F</url>
    <content type="text"><![CDATA[单例模式（Singleton Pattern）属于创建型模式，此模式涉及单一的类与对象，类负责创建自己的对象，同时保证只有一个对象被使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/* * Copyright,ShanNong Inc,2018 and onwards * * Author:fanghua fan */package com.fanghua.designpattrn.singleton;/** * 单例模式, 线程不安全模式 */public class SingletonPattern &#123; private static SingletonPattern object; private SingletonPattern() &#123; &#125; /** * 获取单利对象 * * @return */ private static SingletonPattern getInstance() &#123; if (object == null) &#123; object = new SingletonPattern(); &#125; return object; &#125; private void showInstance() &#123; System.out.println("show instance:" + getClass().hashCode()); &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) SingletonPattern.getInstance().showInstance(); &#125;&#125;/** * 线程安全式 */class SingletonPatternSafe &#123; private static SingletonPatternSafe object; private SingletonPatternSafe() &#123; &#125; /** * 获取单利对象 * * @return */ private static synchronized SingletonPatternSafe getInstance() &#123; if (object == null) &#123; object = new SingletonPatternSafe(); &#125; return object; &#125; private void showInstance() &#123; System.out.println("show instance:" + getClass().hashCode()); &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) SingletonPatternSafe.getInstance().showInstance(); &#125;&#125;/** * 线程安全，但是浪费内存 */class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125;/** * 基于双重校验锁的线程安全式 */class SingletonDoubleLock &#123; private volatile static SingletonDoubleLock singleton; private SingletonDoubleLock() &#123; &#125; public static SingletonDoubleLock getSingleton() &#123; if (singleton == null) &#123; synchronized (SingletonDoubleLock.class) &#123; if (singleton == null) &#123; singleton = new SingletonDoubleLock(); &#125; &#125; &#125; return singleton; &#125;&#125;/** * 基于内部类的线程安全式单例模式 */class SingletonInnerStatic &#123; private static class SingletonHolder &#123; private static final SingletonInnerStatic INSTANCE = new SingletonInnerStatic(); &#125; private SingletonInnerStatic() &#123; &#125; public static final SingletonInnerStatic getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125;/** * 单元素的枚举类型是singleton实现的最佳方法，同时也是线程安全的 */class ObjectResource &#123;&#125;enum SomeThing &#123; INSTANCE; private ObjectResource instance; SomeThing() &#123; instance = new ObjectResource(); &#125; public ObjectResource getInstance() &#123; return instance; &#125;&#125; （全文完）3/31/2018 10:05:32 PM]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cloudstack删除zone方法]]></title>
    <url>%2Fposts%2F28333%2F</url>
    <content type="text"><![CDATA[登录mysql或者mariadb1mysql -uroot -p123456 执行以下sql语句123use cloud; # 进入数据库select data_center_id from physical_network; # 查找所有的物理网络idupdate physical_network set removed=now() where data_center_id=1; # 更新已删除时间为当前时间 手动在zone中删除然后就可以在UI console中删除对应的资源域（zone）]]></content>
      <categories>
        <category>云计算</category>
        <category>cloudstack</category>
      </categories>
      <tags>
        <tag>cloudstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7.4 + Cloudstack4.11 + Xenserver7.2安装配置]]></title>
    <url>%2Fposts%2F13794%2F</url>
    <content type="text"><![CDATA[最近折腾了一下Cloudstack4.11+Xenserver7,2的安装，刚开始使用的Xenserver7.4，最后翻看Cloudstack Supported Hypervisor Versions文档，发现对Xenserver最高只是支持到7.2，出现的问题是安装步骤什么都是正确的，系统VM也是可以正常启动，但是在Xencenter中进入命令行，使用ip a命令查看ip，l列出四个网卡，但是却没有正确分配ip，导致系统VM一直循环创建，无法正常启动，重启后发现status是Running但是代理状态永远都是没有Up，很是纠结郁闷，下面来记录下安装过程： 首先安装 cloudstack management安装之前最好先看下Xenserver和cloudstack各自的硬件要求。 配置hosts查看当前系统hostnamehostname --fqdn localhost 设置hostsvi /etc/hosts 在文件中添加： 182.168.0.111 cloudstack.cloud.priv # cloudstack management管理节点 192.168.0.112 xen1.cloud.priv # xenserver主机节点 查看是否可以ping通该hostping cloudstack.cloud.priv 到时候安装完主机节点也是同样的设置hosts，同时ping一下是否可以ping通 安装NTP时间同步yum install ntp 记得安装xenserver的时候，设置NTP同步节点的ip就是这个管理节点的ip 安装cloudstack management server【必须确保设备可以联网】配置yum安装源vim /etc/yum.repos.d/cloudstack.repo [cloudstack] name=cloudstack baseurl=http://cloudstack.apt-get.eu/centos/$releasever/4.11/ enabled=1 gpgcheck=0 执行安装命令yum install cloudstack-management 下载vhd-utilcd /usr/share/cloudstack-common/scripts/vm/hypervisor/xenserver wget http://download.cloud.com.s3.amazonaws.com/tools/vhd-util chmod 755 -R /usr/share/cloudstack-common/scripts/vm/hypervisor/xenserver 在管理节点上安装MariaDB或者MYSQL配置SELinuxrpm -qa | grep selinux # 查看selinux是否可用 vi /etc/selinux/config 将SELINUX=enforcing更改成SELINUX=permissive setenforce permissive # 配置立即生效 安装配置mariadb数据库yum install mariadb mariadb-server vi /etc/my.cnf [mysqld] innodb_rollback_on_timeout=1 innodb_lock_wait_timeout=600 max_connections=350 log-bin=mysql-bin binlog-format = &apos;ROW&apos; 启动数据库并设置为开机启动systemctl start mariadb ###启动数据库 systemctl enable mariadb ###开机自启动 初始化数据库mysql_secure_installation 设置密码然后一路yyyy （yes） 使用cloudstack-setup-databases初始化ClouStack数据库：后面如果安装配置失败，可以执行此命令重置数据库 cloudstack-setup-databases cloud:cloud@localhost --deploy-as=root:123456 -i 192.168.100.4 ### 192.168.100.4是当前系统的本地ip ### 重置数据库123456数据库密码 cloudstack安装tomcat服务器cloudstack-setup-management 安装NFS[网络文件系统]我的是在管理节点下面安装的NFS serveryum install nfs-utils # 有可能会无法下载，但是会自动重试 管理节点上创建主存储和二级存储的文件目录可以找一个容量空余比较硬盘创建，否则后面创建VM可能会报系统容量不足的异常 mkdir -p /export/primary mkdir -p /export/secondary 配置NFS文件目录导出vi /etc/exports 添加： /export/primary *(rw,async,no_root_squash,no_subtree_check) /export/secondary *(rw,async,no_root_squash,no_subtree_check) 导出目录exportfs -a 编辑配置nfs端口vi /etc/sysconfig/nfs 直接添加： LOCKD_TCPPORT=32803 LOCKD_UDPPORT=32769 MOUNTD_PORT=892 RQUOTAD_PORT=875 STATD_PORT=662 STATD_OUTGOING_PORT=2020 可以直接关闭防火墙（测试环境）或者在防火墙上开端口（点击查看配置）注意：centos7以上好像废弃了iptables，改用firewall，只需打开对应端口即可 如果客户机和服务器之间使用nfs v4通信，那么将域添加到管理程序主机和管理服务器上vi /etc/idmapd.conf 修改Domain = cloud.priv # 后缀名要一致 我的配置： 182.168.0.111 cloudstack.cloud.priv # cloudstack management管理节点 192.168.0.112 xen1.cloud.priv # xenserver主机节点 在安装好的主机节点上测试NFS挂载是否可以成功，这一步是在安装Xenserver主机后验证是否可以正常挂载，否则添加主存储和二级存储会出现问题mkdir /primary mount -t nfs &lt;management-server-name&gt;:/export/primary umount /primary mkdir /secondary mount -t nfs &lt;management-server-name&gt;:/export/secondary umount /secondary 下载安装系统VM魔板这个过程是比较慢的，可以使用迅雷或者其他加速加载工具下载模板到本地，然后再导入，注意下载的版本要对应，现在4.11的安装文档还是下载4.6的模板，如果下载4.6的模板，可能会出现问题，例如4.11的下载路径（http://cloudstack.apt-get.eu/systemvm/4.11/systemvm64template-4.11.0-xen.vhd.bz2） /usr/share/cloudstack-common/scripts/storage/secondary/cloud-install-sys-tmplt \ -m /mnt/secondary \ -u http://cloudstack.apt-get.eu/systemvm/4.11/systemvm64template-4.11.0-xen.vhd.bz2 \ -h xenserver \ -s &lt;optional-management-server-secret-key&gt; \ -F 然后安装Xenserver安装成功后进入命令行,配置XenServer dom0 Memoryvim /etc/xensource-inventory BUILD_NUMBER=&apos;39265p&apos; CURRENT_INTERFACES=&apos;xenbr0 xenbr1&apos; DOM0_MEM=&apos;752&apos; ----------------------------------------------------------修改成2940 PRODUCT_BRAND=&apos;XenServer&apos; INSTALLATION_UUID=&apos;68406e3e-eeac-4b15-9b30-0bd37d95473b&apos; KERNEL_VERSION=&apos;2.6.32.12-0.7.1.xs5.6.100.307.170586xen&apos; DEFAULT_SR_PHYSDEVS=&apos;/dev/sda3&apos; CONTROL_DOMAIN_UUID=&apos;69d22f7c-417b-4b84-af8f-4a7bea6fc83b&apos; PRIMARY_DISK=&apos;/dev/disk/by-id/scsi-366c92bf00002d66015e6a64b16a0aa2d&apos; XEN_VERSION=&apos;3.4.2&apos; BACKUP_PARTITION=&apos;/dev/disk/by-id/scsi-366c92bf00002d66015e6a64b16a0aa2d-part2&apos; PRODUCT_NAME=&apos;xenenterprise&apos; INSTALLATION_DATE=&apos;2011-05-23 12:29:49.057341&apos; PRODUCT_VERSION=&apos;5.6.100&apos; MANAGEMENT_INTERFACE=&apos;xenbr0&apos; 如果你安装的时候没有选择安装NTP，则现在你需要手动安装NTPyum install ntp # 安装ntp vi /etc/ntp.conf # 配置ntp,下面是配置内容 server 0.xenserver.pool.ntp.org server 1.xenserver.pool.ntp.org server 2.xenserver.pool.ntp.org server 3.xenserver.pool.ntp.org service ntpd restart # 启动ntp chkconfig ntpd on # 设置开机启动 如果后面要配置基本网络模式，应该将网络配置成网桥模式xe-switch-network-backend bridge # 执行该命令会提示重启xenserver 配置： vi /etc/sysctl.conf net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 0 net.bridge.bridge-nf-call-arptables = 1 sysctl -p /etc/sysctl.conf XenServer物理网络安装先使用命令查看物理网络uuid: 1234567891011xe network-list xenserver有两块物理网卡, 上述命令会显示xenbr0和xenbr1的网络UUID, 假设 uuid ( RO) : 3489fa11-66ed-6a71-926b-5336d69c62babridge ( RO): xenbr0 uuid ( RO) : eb734bff-750b-ecac-32b6-9490179f9d33bridge ( RO): xenbr1则执行以下命令：# xe network-param-set name-label=mgtpub uuid=3489fa11-66ed-6a71-926b-5336d69c62ba# xe network-param-set name-label=guest uuid=eb734bff-750b-ecac-32b6-9490179f9d33 (全文完) 3/31/2018 12:57:35 PM]]></content>
      <categories>
        <category>云计算</category>
        <category>cloudstack</category>
      </categories>
      <tags>
        <tag>cloudstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[享元模式]]></title>
    <url>%2Fposts%2F65163%2F</url>
    <content type="text"><![CDATA[享元模式（Flyweight Pattern）是结构型模式中的一种，主要用于减少创建对象的数量，以减少内存占用和提高性能。它减少对象数量，从而改善应用所需的对象结构的方式。其中最经典的应用就是JDK中String的实现，相同变量值的String都会放入同一个地址，然后这些变量指向这些地址，当有变量值变化时，变量的引用会重新查找指向地址，如果没有相同变量值得地址，则复制到新的地址。同样的，享元模式就是是使用这一种模式，减少创建相同对象数量从而使内存开销更小。 使用场景： 1、系统有大量相似对象。 2、需要缓冲池的场景。 /* * Copyright,ShanNong Inc,2018 and onwards * * Author:fanghua fan */ package com.fanghua.designpattrn.flyweightpattern; import java.util.HashMap; import java.util.Map; /** * 数学抽象类 */ public interface Math { String study(); String happy(String name); } /** * 创建数学下几何学对象 */ class Geometry implements Math { String chapters; public Geometry(String chapters) { this.chapters = chapters; } public String study() { System.out.println("Good content!" + chapters); return "Good content!" + chapters; } public String happy(String name) { return name + " happy to learn " + chapters; } } /** * 创建一个几何学学习工厂 */ class MathStudyFactory { private static final Map&lt;String, Math&gt; shareObject = new HashMap&lt;String, Math&gt;(); /** * 获取学习内容 * * @param chapters * @return */ public static Math getMathContent(String chapters) { Math findRes = shareObject.get(chapters); // 判断共享池中是否存在此章节 if (findRes == null) { findRes = new Geometry(chapters); shareObject.put(chapters, findRes); } return findRes; } } /** * 数学家们学习数学 */ class MathematicianStory { static String[] chapters = {"平面几何", "立体几何", "解析几何"}; public static void main(String[] args) { // 100万个数学家学习 for (int i = 0; i &lt; 100; i++) { Math resObject = MathStudyFactory.getMathContent(getRandomChapter()); resObject.study(); String happyDone = resObject.happy(java.lang.Math.random() + ""); System.out.println("Done: " + happyDone); } } private static String getRandomChapter() { return chapters[(int) (java.lang.Math.random() * chapters.length)]; } } (全文完)3/30/2018 11:43:29 PM]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7查看版本号]]></title>
    <url>%2Fposts%2F48293%2F</url>
    <content type="text"><![CDATA[查看版本号1ll /etc/*centos* -rw-r–r–. 1 root root 38 8月 30 2017 /etc/centos-release-rw-r–r–. 1 root root 51 8月 30 2017 /etc/centos-release-upstream 查看CentOS的版本号1cat /etc/centos-release CentOS Linux release 7.4.1708 (Core) 查看内核版本1uname -r 3.10.0-327.el7.x86_64 查看操作系统位数1getconf LONG_BIT 64]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String源码研究]]></title>
    <url>%2Fposts%2F38677%2F</url>
    <content type="text"><![CDATA[先来解决一个比较经典的问题，String为什么是final?final的出现就是为了为了不想改变，而不想改变的理由有两点：设计(安全)或者效率。 1、从设计安全上讲，1)、确保它们不会在子类中改变语义。String类是final类，这意味着不允许任何人定义String的子类。换言之，如果有一个String的引用，它引用的一定是一个String对象，而不可能是其他类的对象。2)、String 一旦被创建是不能被修改的， 2、从效率上讲：1)、设计成final，JVM才不用对相关方法在虚函数表中查询，而直接定位到String类的相关方法上，提高了执行效率。2)、Java设计者认为共享带来的效率更高，即采用了享元模式,每当生成一个新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，就共享此对象，而不是创建一个新对象，但是这样的做法仅仅适合于通过=符号进行的初始化。 参考文献https://blog.csdn.net/qq_27093465/article/details/52190915https://www.cnblogs.com/zhangyinhua/p/7689974.html 3/27/2018 11:16:57 PM]]></content>
      <categories>
        <category>JAVA</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识体系]]></title>
    <url>%2Fposts%2F3353%2F</url>
    <content type="text"><![CDATA[一、Java基础知识阅读源代码String、Integer、Long、Enum、BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、ArrayList &amp; LinkedList、 HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet Java中各种变量类型熟悉Java String的使用，熟悉String的各种函数JDK 6和JDK 7中substring的原理及区别、 replaceFirst、replaceAll、replace区别String对“+”的重载、String.valueOf和Integer.toString的区别字符串的不可变性自动拆装箱Integer的缓存机制 熟悉Java中各种关键字transient，instanceof、volatile、synchronized、final、static、const 原理及用法。 集合类常用集合类的使用 ArrayList和LinkedList和Vector的区别 SynchronizedList和Vector的区别 HashMap、HashTable、ConcurrentHashMap区别 Java 8中stream相关用法 apache集合处理工具类的使用 不同版本的JDK中HashMap的实现的区别以及原因 枚举枚举的用法、枚举与单例、Enum类 Java IO&amp;Java NIO，并学会使用bio、nio和aio的区别、三种IO的用法与原理、netty Java反射与javassist反射与工厂模式、 java.lang.reflect.* Java序列化什么是序列化与反序列化、为什么序列化 序列化底层原理序列化与单例模式 protobuf 为什么说序列化并不安全 注解元注解、自定义注解、Java中常用注解使用、注解与反射的结合 JMS什么是Java消息服务、JMS消息传送模型 JMXjava.lang.management.、 javax.management. 泛型泛型与继承 类型擦除泛型中K T V E object等的含义、泛型各种用法 单元测试junit、mock、mockito、内存数据库（h2） 正则表达式java.lang.util.regex.* 常用的Java工具库commons.lang, commons.*… guava-libraries netty 什么是API&amp;SPI异常异常类型、正确处理异常、自定义异常 时间处理时区、时令、Java中时间API 编码方式解决乱码问题、常用编码方式 语法糖Java中语法糖原理、解语法糖 Java并发编程什么是线程，与进程的区别阅读源代码，并学会使用Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、、ConcurrentHashMap、Executors 线程池自己设计线程池、submit() 和 execute() 线程安全死锁、死锁如何排查、Java线程调度、线程安全和内存模型的关系 锁CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁 死锁volatilehappens-before、编译器指令重排和CPU指令重 synchronizedsynchronized是如何实现的？ synchronized和lock之间关系不使用synchronized如何实现一个线程安全的单例 sleep 和 waitwait 和 notifynotify 和 notifyAllThreadLocal写一个死锁的程序写代码来解决生产者消费者问题守护线程守护线程和非守护线程的区别以及用法 二、JVMJVM内存结构堆、栈、方法区、直接内存、堆和栈区别 Java内存模型内存可见性、重排序、顺序一致性、volatile、锁、final 垃圾回收内存分配策略、垃圾收集器（G1）、GC算法、GC参数、对象存活的判定 JVM参数及调优Java对象模型oop-klass、对象头 HotSpot即时编译器、编译优化 类加载机制classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw） 虚拟机性能监控与故障处理工具jps, jstack, jmap、jstat, jconsole, jinfo, jhat, javap, btrace、TProfiler 编译与反编译javac 、javap 、jad 、CRF 三、 进阶篇Java底层知识字节码、class文件格式CPU缓存，L1，L2，L3和伪共享尾递归位运算用位运算实现加、减、乘、除、取余 设计模式了解23种设计模式会使用常用设计模式单例、策略、工厂、适配器、责任链。 实现AOP实现IOC不用synchronized和lock，实现线程安全的单例模式nio和reactor设计模式网络编程tcp、udp、http、https等常用协议三次握手与四次关闭、流量控制和拥塞控制、OSI七层模型、tcp粘包与拆包http/1.0 http/1.1 http/2之前的区别Java RMI，Socket，HttpClientcookie 与 sessioncookie被禁用，如何实现session用Java写一个简单的静态文件的HTTP服务器实现客户端缓存功能，支持返回304 实现可并发下载一个文件 使用线程池处理客户端请求 使用nio处理客户端请求 支持简单的rewrite规则 上述功能在实现的时候需要满足“开闭原则” 了解nginx和apache服务器的特性并搭建一个对应的服务器用Java实现FTP、SMTP协议进程间通讯的方式什么是CDN？如果实现？什么是DNS？反向代理框架知识Servlet线程安全问题Servlet中的filter和listenerHibernate的缓存机制Hiberate的懒加载Spring Bean的初始化Spring的AOP原理自己实现Spring的IOCSpring MVCSpring Boot2.0Spring Boot的starter原理，自己实现一个starterSpring Security应用服务器JBosstomcatjettyWeblogic工具git &amp; svnmaven &amp; gradle 四、 高级篇新技术 Java 8lambda表达式、Stream API、 Java 9Jigsaw、Jshell、Reactive Streams Java 10局部变量类型推断、G1的并行Full GC、ThreadLocal握手机制 Spring 5响应式编程 Spring Boot 2.0性能优化使用单例、使用Future模式、使用线程池、选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存 线上问题分析dump获取线程Dump、内存Dump、gc情况 dump分析分析死锁、分析内存泄露 自己编写各种outofmemory，stackoverflow程序HeapOutOfMemory、 Young OutOfMemory、MethodArea OutOfMemory、ConstantPool OutOfMemory、DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow 常见问题解决思路内存溢出、线程死锁、类加载冲突 使用工具尝试解决以下问题，并写下总结当一个Java程序响应很慢时如何查找问题、 当一个Java程序频繁FullGC时如何解决问题、如何查看垃圾回收日志、当一个Java应用发生OutOfMemory时该如何解决、如何判断是否出现死锁、如何判断是否存在内存泄露编译原理知识 编译与反编译 Java代码的编译与反编译 Java的反编译工具 词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化 操作系统知识 Linux的常用命令 进程同步 缓冲区溢出 分段和分页 虚拟内存与主存 数据库知识 MySql 执行引擎 MySQL 执行计划 如何查看执行计划，如何根据执行计划进行SQL优化 SQL优化 事务：事务的隔离级别、事务能不能实现锁的功能 数据库锁：行锁、表锁、使用数据库锁实现乐观锁、 数据库主备搭建 binlog 内存数据库 h2 常用的nosql数据库 redis、memcached 分别使用数据库锁、NoSql实现分布式锁 性能调优 五、数据结构与算法知识简单的数据结构 栈 队列 链表 数组 哈希表、 树 二叉树 字典树 平衡树 排序树 B树 B+树 R树 多路树 红黑树 排序算法 八大排序算法实现 各种排序算法和时间复杂度 深度优先和广度优先搜索 全排列 贪心算法 KMP算法 hash算法 海量数据处理 大数据知识 Zookeeper基本概念、常见用法 Solr，Lucene，ElasticSearch在linux上部署solr，solrcloud，，新增、删除、查询索引 Storm，流式计算，了解Spark，S4在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。 Hadoop，离线计算HDFS、MapReduce 分布式日志收集flume，kafka，logstash数据挖掘，mahout 网络安全知识 什么是XSS XSS的防御 什么是CSRF 什么是注入攻击 SQL注入、XML注入、CRLF注入 什么是文件上传漏洞 加密与解密 MD5，SHA1、DES、AES、RSA、DSA 什么是DOS攻击和DDOS攻击 memcached为什么可以导致DDos攻击、什么是反射型DDoS SSL、TLS，HTTPS 如何通过Hash碰撞进行DOS攻击 用openssl签一个证书部署到apache或nginx 六、架构篇分布式数据一致性、服务治理、服务降级 分布式事务2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC Dubbo服务注册、服务发现，服务治理 分布式数据库怎样打造一个分布式数据库、什么时候需要分布式数据库、mycat、otter、HBase 分布式文件系统mfs、fastdfs 分布式缓存缓存一致性、缓存命中率、缓存冗余 微服务SOA、康威定律 Tencent TarsServiceMeshDocker &amp; KubernetsSpring BootSpring Cloud高并发分库分表CDN技术消息队列ActiveMQ监控监控什么CPU、内存、磁盘I/O、网络I/O等 监控手段进程监控、语义监控、机器资源监控、数据波动 监控数据采集日志、埋点 Dapper负载均衡tomcat负载均衡、Nginx负载均衡 DNSDNS原理、DNS的设计 CDN数据一致性 七、 扩展篇云计算IaaS、SaaS、PaaS、虚拟化技术、openstack、cloudstack、Serverlsess 搜索引擎Solr、Lucene、Nutch、Elasticsearch 权限管理Shiro 区块链哈希算法、Merkle树、公钥密码算法、共识算法、Raft协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名 比特币挖矿、共识机制、闪电网络、侧链、热点问题、分叉 以太坊超级账本 人工智能数学基础、机器学习、人工神经网络、深度学习、应用场景。 常用框架TensorFlow、DeepLearning4J 其他语言Groovy、Python、Go、NodeJs、Swift、Rust 3/26/2018 10:40:04 PM引用文献：https://mp.weixin.qq.com/s/UKwZkwYmDSVTbj62ACuapg]]></content>
      <categories>
        <category>JAVA</category>
        <category>知识体系</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-no4]]></title>
    <url>%2Fposts%2F29847%2F</url>
    <content type="text"><![CDATA[本文只要使用两种解法解决两个有序数组O(m+n)时间复杂度查找其中位数的算法。 解法一：遍历合并数组因为两个数组都是遍历的，所以通过遍历比较大的数组比较两个数组的值，直到其值为两个数组之和的一半下标为止 解法二：分治算法此算法是对第一种算法的优化，采用分治算法的思想，结合二分法进行中位值查找 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * Copyright,ShanNong Inc,2018 and onwards * * Author:fanghua fan */package com.fanghua.algorithm.divideandconquer;/** * leetcode * &lt;p&gt; * 4. Median of Two Sorted Arrays * &lt;p&gt; * There are two sorted arrays nums1 and nums2 of size m and n respectively. * &lt;p&gt; * Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). * &lt;p&gt; * Example 1: * nums1 = [1, 3] * nums2 = [2] * &lt;p&gt; * The median is 2.0 * Example 2: * nums1 = [1, 2] * nums2 = [3, 4] * &lt;p&gt; * The median is (2 + 3)/2 = 2.5 */public class SolutionNum4 &#123; /** * 1、因为两个数组都是遍历的，所以通过遍历比较大的数 * 组比较两个数组的值，直到其值为两个数组之和的一半下标为止 * * @param nums1 * @param nums2 * @return 中位值 */ public static double findMedianToIterator(int[] nums1, int[] nums2) &#123; int len1 = nums1.length; int len2 = nums2.length; int allLen = len1 + len2; int[] temp = (len1 &gt; len2) ? nums1 : nums2; int arrayFlag = 0;// 判断当前遍历最后一个数是哪个数组 for (int index1 = 0, index2 = 0; ; ) &#123; // 中位值判断 if (index1 + index2 == allLen / 2) &#123; int left = 0; if (index1 - 1 &gt;= 0 &amp;&amp; arrayFlag == 1) &#123; left = nums1[index1 - 1]; &#125; else if (index2 - 1 &gt;= 0 &amp;&amp; arrayFlag == 2) &#123; left = nums2[index2 - 1]; &#125; int right = Math.min(len1 == 0 ? Integer.MAX_VALUE : (index1 &gt;= len1 ? nums2[index2] : nums1[index1]), len2 == 0 ? Integer.MAX_VALUE : (index2 &gt;= len2 ? nums1[index1] : nums2[index2])); if (allLen % 2 == 1) &#123; return (right) / 1.0; &#125; else &#123; return (left + right) / 2.0; &#125; &#125; // 值判断 if (len2 == 0 || index2 &gt;= len2 || (len1 != 0 &amp;&amp; index1 &lt; len1 &amp;&amp; nums1[index1] &lt; nums2[index2])) &#123; index1++;// 第一个数组指针向后移动 arrayFlag = 1; &#125; else &#123; index2++; arrayFlag = 2; &#125; &#125; &#125; /** * 2、此算法是对第一种算法的优化，采用分治算法的思想，结合二分法进行中位值查找 * * @param nums1 * @param nums2 * @return */ public static double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int n = nums1.length; int m = nums2.length; if (n &gt; m) &#123; //保证数组1一定最短 return findMedianSortedArrays(nums2, nums1); &#125; int L1 = 0, L2 = 0, R1 = 0, R2 = 0, c1, c2, lo = 0, hi = 2 * n; while (lo &lt;= hi) &#123; //二分 c1 = (lo + hi) / 2; //c1是二分的结果 c2 = m + n - c1; L1 = (c1 == 0) ? Integer.MIN_VALUE : nums1[(c1 - 1) / 2]; //map to original element R1 = (c1 == 2 * n) ? Integer.MAX_VALUE : nums1[c1 / 2]; L2 = (c2 == 0) ? Integer.MIN_VALUE : nums2[(c2 - 1) / 2]; R2 = (c2 == 2 * m) ? Integer.MAX_VALUE : nums2[c2 / 2]; if (L1 &gt; R2) &#123; hi = c1 - 1; &#125; else if (L2 &gt; R1) &#123; lo = c1 + 1; &#125; else &#123; break; &#125; &#125; return (Math.max(L1, L2) + Math.min(R1, R2)) / 2.0; &#125;&#125; （全文完）3/25/2018 8:57:58 PM]]></content>
      <categories>
        <category>Algorithm</category>
        <category>leetcode</category>
        <category>分治算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>leetcode</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存结构]]></title>
    <url>%2Fposts%2F27692%2F</url>
    <content type="text"><![CDATA[JVM概念JVM(Java Virtual Machine)，其实就是对真实计算机系统的模拟，正因如此才能屏蔽物理机器的变化，从而提供Java程序运行的环境，实现“一次编译，到处运行”。 JVM内存结构JVM内存结构概念JVM在执行Java程序时，会把它管理的内存划分为若干个的区域，每个区域都有自己的用途和创建销毁时间，可以分为两大部分，线程私有区和共享区。而共享区有方法区和堆，私有区则有程序计数器、虚拟机栈、本地方法栈等数据区域。 方法区 方法区（Method Area）是用于存储类结构信息的地方，包括常量池、静态变量、构造函数等类型信息，类型信息是由类加载器在类加载时从类文件中提取出来的。 方法区同样存在垃圾收集，因为用户通过自定义加载器加载的一些类同样会成为垃圾，JVM会回收一个未被引用类所占的空间，以使方法区的空间达到最小。 方法区中还存在着常量池，常量池包含着一些常量和符号引用（加载类的连接阶段中的解析过程会将符号引用转换为直接引用）。 方法区是线程共享的。 堆 堆（heap）是存储java实例或者对象的地方，是GC的主要区域，同样是线程共享的内存区域。 Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 程序计数器程序计数器（Program Counter Register）是JVM中一块较小的内存区域，保存着当前线程执行的虚拟机字节码指令的内存地址。Java多线程的实现，其实是通过线程间的轮流切换并分配处理器执行时间的方式来实现的，在任何时刻，处理器都只会执行一个线程中的指令。在多线程场景下，为了保证线程切换回来后，还能恢复到原先状态，找到原先执行的指令，所以每个线程都会设立一个程序计数器，并且各个线程之间不会互相影响，程序计数器为”线程私有”的内存区域。 如果当前线程正在执行Java方法，则程序计数器保存的是虚拟机字节码的内存地址，如果正在执行的是Native方法（非Java方法，JVM底层有许多非Java编写的函数实现），计数器则为空。程序计数器是唯一一个在Java规范中没有规定任何OutOfMemory场景的区域。 虚拟机栈虚拟机栈（Java Virtual Machine Stacks）和线程是紧密联系的，每创建一个线程时就会对应创建一个Java栈，所以Java栈也是”线程私有”的内存区域，这个栈中又会对应包含多个栈帧，每调用一个方法时就会往栈中创建并压入一个栈帧，栈帧是用来存储方法数据和部分过程结果的数据结构，每一个方法从调用到最终返回结果的过程，就对应一个栈帧从入栈到出栈的过程。 虚拟机栈是一个后入先出的数据结构，线程运行过程中，只有一个栈帧是处于活跃状态的，被称为”当前活动帧栈”，当前活动帧栈始终是虚拟机栈的栈顶元素。 本地方法栈 本地方法栈（Native Method Stack）和虚拟机栈的作用相似，不过虚拟机栈是为Java方法服务的，而本地方法栈是为Native方法服务的。 JAVA堆和栈（内存）的区别 Java栈存储基本类型变量和对引用，Java堆则存取对象和数组实例； 栈(stack)与堆(heap)都是Java用来在RAM中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 栈存取速度比堆快，仅次与CPU寄存器，栈中的数据大小和生存期必须是确定的；堆是可以动态分配内存大小的，栈在运行时动态分配内存，存取速度较栈慢。 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。 如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。 （全文完）3/23/2018 10:38:18 PM https://www.cnblogs.com/jiyukai/p/6665199.html]]></content>
      <categories>
        <category>JAVA</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机外部无法访问虚拟机内Linux系统IP的问题]]></title>
    <url>%2Fposts%2F60429%2F</url>
    <content type="text"><![CDATA[主要是因为主机IP和虚拟机IP不在同一网段的问题，我直接把vimnet8中的TCP/IPv4设置成自动获取IP地址即可ping通，如果要访问端口，可以在防火墙上打开特定端口或者直接关闭防火墙。操作如图：]]></content>
      <categories>
        <category>云计算</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>云计算</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7+CloudStack+KVM基础搭建文档]]></title>
    <url>%2Fposts%2F47209%2F</url>
    <content type="text"><![CDATA[关闭selinuxsed -i s#&apos;SELINUX=enforcing&apos;#&apos;SELINUX=disabled&apos;#g /etc/selinux/config setenforce 0 关闭防火墙systemctl stop firewalld systemctl disable firewalld 安装NTP（时间同步）yum -y install ntp systemctl enable ntpd 安装ManagementServer（管理端的源）vi /etc/yum.repos.d/cloudstack.repo [cloudstack] name=cloudstack baseurl=http://cloudstack.apt-get.eu/centos/7/4.8/ enabled=1 gpgcheck=0 安装Cloudstack管理serveryum -y install cloudstack-management 安装数据库（mysql和mariadb都可以）yum install mariadb mariadb-server vi /etc/my.cnf [mysqld] innodb_rollback_on_timeout=1 innodb_lock_wait_timeout=600 max_connections=350 log-bin=mysql-bin binlog-format = &apos;ROW&apos; 启动数据库并设置为开机启动systemctl start mariadb ###启动数据库 systemctl enable mariadb ###开机自启动 初始化数据库mysql_secure_installation ###设置密码然后一路yyyy （yes） 使用cloudstack-setup-databases初始化ClouStack数据库：cloudstack-setup-databases cloud:cloud@localhost --deploy-as=root:123456 -i 192.168.100.4 ### 192.168.100.4是当前系统的本地ip ### 重置数据库123456数据库密码 cloudstack安装tomcat服务器cloudstack-setup-management --tomcat7 启动cloudstacksystemctl start cloudstack-management 配置NFS存储yum -y install nfs-utils rpcbind 配置域名（随意配置）vi /etc/idmapd.conf Domain = xxx 准备NFS目录mkdir -p /data/cloudstack/{primary,secondary} 修改nfs服务参数vim /etc/sysconfig/nfs （直接加载结尾也可以） LOCKD_TCPPORT=32803 LOCKD_UDPPORT=32769 RQUOTAD_PORT=875 MOUNTD_PORT=892 STATD_PORT=662 STATD_OUTGOING_PORT=2020 RPCNFSDARGS=&quot;-N 4&quot; 配置文件vim /etc/exports /data/cloudstack/primary *(rw,async,no_root_squash,no_subtree_check) /data/cloudstack/secondary *(rw,async,no_root_squash,no_subtree_check) 设置nfs挂载配置文件vim /etc/nfsmount.conf Nfsvers=3 启动nfs和rpcbindsystemctl enable rpcbind systemctl enable nfs-server systemctl start rpcbind systemctl start nfs-server 测试挂载mount -t nfs 192.168.100.4:/data/cloudstack/primary /mnt df -h ###查看有了代表成功 umount /mnt 下载系统VM模板/usr/share/cloudstack-common/scripts/storage/secondary/cloud-install-sys-tmplt -m /data/cloudstack/secondary -u http://cloudstack.apt-get.eu/systemvm/4.6/systemvm64template-4.6.0-kvm.qcow2.bz2 -h kvm -F 安装agent（cloudstack主机，如果部署集群，备机只需要直接部署agent）yum -y install cloudstack-agent 配置文件修改vi /etc/libvirt/qemu.conf 并取消如下行的注释 vnc_listen=0.0.0.0 配置KVMvi /etc/libvirt/libvirtd.conf listen_tls = 0 listen_tcp = 1 tcp_port = &quot;16059&quot; auth_tcp = &quot;none&quot; mdns_adv = 0 vi /etc/sysconfig/libvirtd LIBVIRTD_ARGS=&quot;--listen&quot; systemctl restart libvirtd systemctl enable libvirtd 配置agentvi /etc/cloudstack/agent/agent.properties host=192.168.100.4 配置网卡（做桥接）网卡1 vi /etc/sysconfig/network-scripts/ifcfg-em1 ###编辑第一块网卡 是什么就编辑什么 我这叫em1 TYPE=Ethernet IPV6INIT=no DEVICE=em1 ONBOOT=yes BRIDGE=cloudbr0 网卡桥接 vi /etc/sysconfig/network-scripts/ifcfg-cloudbr0 ####名字也可以自定义，要和里边配置对应上 TYPE=Bridge BOOTPROTO=static DEVICE=cloudbr0 IPV6INIT=no ONBOOT=yes IPADDR=192.168.100.4 NETMASK=255.255.255.0 GATEWAY=192.168.110.1 DNS1=202.106.0.20###我写了个公网的 初始化cloudstack-agentcloudstack-setup-agent ##一路回车 systemctl restart cloudstack-agent systemctl restart libvirtd 查看8080端口是否启动netstat -tunlp|grep 8080 打开浏览器，我们进行下一步配置http://192.168.100.4:8080/client/ 账号admin 密码password 参考文献：http://www.cnblogs.com/wsy1030/p/8430351.html]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
</search>
